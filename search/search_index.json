{"config":{"lang":["es"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Informaci\u00f3n B\u00e1sica","text":""},{"location":"#clases","title":"Clases","text":"<p>Horario: 14:00-18:20</p> <p>Sala Javier Pinto, DCC (4to piso Edificio San Agust\u00edn, el primero a mano derecha desde el metro)</p>"},{"location":"#profesor","title":"Profesor","text":"<p>Mart\u00edn Mu\u00f1oz (mmunos@uc.cl)</p>"},{"location":"#ayudante","title":"Ayudante","text":"<p>Benjam\u00edn Rubio (berubio@uc.cl)</p>"},{"location":"#telegram-del-curso-medio-oficial-de-comunicacion","title":"Telegram del curso (medio oficial de comunicaci\u00f3n)","text":"<p>Unirse </p>"},{"location":"#spreadsheet-de-notas-y-asistencia","title":"Spreadsheet de notas y asistencia","text":"<p>Ver spreadsheet </p>"},{"location":"ethics/","title":"\u00c9tica e Integridad Acad\u00e9mica","text":""},{"location":"ethics/#tldr","title":"TL;DR","text":"<ol> <li>You shall not copy-paste c\u00f3digo ajeno (hay penas del infierno por hacer esto).</li> <li>Por un tema pedag\u00f3gico, siempre intenta hacer los problemas por ti mism primero. No obstante, si sientes que se est\u00e1 poniendo muy complicada la cosa, tenemos varios tips sobre c\u00f3mo recibir apoyo/ayuda sin salirse de los m\u00e1rgenes de la \u00e9tica (ver detalles abajo).</li> </ol>"},{"location":"ethics/#detalles","title":"Detalles","text":"<p>Puedes hacer uso de recursos en l\u00ednea al resolver problemas. Esto incluye documentaci\u00f3n de tu lenguaje de programaci\u00f3n favorito, descripciones de algoritmos, implementaciones est\u00e1ndar de ciertos algoritmos y estructuras de datos como referencia, wikipedia, youtube, libros, tutoriales, etc. Es m\u00e1s, en caso de desesperaci\u00f3n en este curso est\u00e1 incluso permitido consultar soluciones de ejemplo. Sin embargo, LA COPIA DESCARADA DE SOLUCIONES AJENAS est\u00e1 terminantemente PROHIBIDA. Por favor, NUNCA hagas copy paste de c\u00f3digos ajenos. La idea del curso es que aprendas a programar tus propias soluciones, y hacer copy paste sabotea completamente dicho prop\u00f3sito. Para evitar pasar malos ratos, nuestra recomendaci\u00f3n al enfrentar problemas es la siguiente:</p> <ol> <li> <p>Primero intenta resolver los problemas por ti mism, trata de no usar ning\u00fan recurso externo (esto incluye el uso de alg\u00fan AI) excepto por quiz\u00e1 documentaci\u00f3n del lenguaje de programaci\u00f3n que est\u00e1s usando (por ej. si se te olvid\u00f3 c\u00f3mo se usaba cierta cosa de la librer\u00eda est\u00e1ndar)</p> </li> <li> <p>Si un problema est\u00e1 muy dif\u00edcil, intenta cambiarte a otro problema m\u00e1s f\u00e1cil (puedes ver los problemas m\u00e1s resueltos en el scoreboard, probablemente son los m\u00e1s f\u00e1ciles).</p> </li> <li> <p>Eventualmente si llegas a un punto en que te sientes pegad con todos los problemas que quedan, entonces es tiempo de pedir ayuda. Tanto el profesor como el ayudante estamos a tu disposici\u00f3n para ayudarte en cualquier tipo de duda que tengas, te\u00f3rica, de c\u00f3digo, alg\u00fan bug, lo que sea. Estamos disponibles 24/7/365. Puedes hacernos preguntas por el telegram del curso, chateando uno-a-uno con nosotros por telegram, etc. Adem\u00e1s de nosotros, tambi\u00e9n hay hartas personas con experiencia en progcomp que te pueden ayudar. Si tienes una duda y la planteas abiertamente en el Telegram del curso, todos podremos ayudarte y quiz\u00e1s tu duda le sirva alg\u00fan otr compa\u00f1er que tenga la misma duda.</p> </li> <li> <p>Si lo anterior no es suficiente, tambi\u00e9n puedes googlear explicaciones te\u00f3ricas (palabras) en internet. Tambi\u00e9n puedes consultar material de estudio, c\u00f3digos de estructuras de datos y algoritmos est\u00e1ndar, etc. Si haces esto, por favor incluye las referencias (links) en tu c\u00f3digo, explicando qu\u00e9 fuentes consultaste y en qu\u00e9 te ayudaron.</p> </li> <li> <p>Si las explicaciones te\u00f3ricas y recursos est\u00e1ndar de referencia no son suficientes, como medida de desesperaci\u00f3n y \u00faltimo recurso te est\u00e1 \u00e9ticamente permitido mirar soluciones ajenas de ejemplo, pero bajo la condici\u00f3n de que por ning\u00fan motivo hagas copy-paste. Esto incluye tanto las soluciones de ejemplo subidas por nosotros (staff) como las soluciones que googlees por tu cuenta de internet. Cualquiera sea el caso, si tomas la decisi\u00f3n de mirar soluciones ajenas, debes referenciar los c\u00f3digos que miraste, dejando bien claro en qu\u00e9 te ayudaron (qu\u00e9 fue lo que entendiste o aprendiste del c\u00f3digo ajeno que consultaste, quiz\u00e1s aprendiste una t\u00e9cnica de programaci\u00f3n que no se te hab\u00eda ocurrido antes?) y dejando bien claro que tu c\u00f3digo NO es un copy-paste del c\u00f3digo ajeno.</p> </li> <li> <p>Finalmente, ten presente que vjudge.net le otorga al autor de un contest acceso a las soluciones de los participantes ... S\u00ed, tanto el profesor como el ayudante tenemos acceso a sus c\u00f3digos. Si alguien misteriosamente resuelve un problema dif\u00edcil, tenga la seguridad de que con probabilidad muy alta su c\u00f3digo ser\u00e1 examinado por nosotros :)</p> </li> </ol> <p>Si llegamos a descubrir una copia, el  castigo consistir\u00e1 en lo siguiente:</p> <p>1) Primera copia: nota_final \\(= \\max(\\min(\\operatorname{Nota}_{V3}, 7) - 3, 1)\\)</p> <p>2) Segunda copia: nota_final \\(= 1 +\\) causal de eliminaci\u00f3n</p> <p>3) Tercera copia: Exilio.</p>"},{"location":"help/","title":"Auxilio, estoy pegad, no s\u00e9 resolver un problema, no se me ocurre, no s\u00e9 implementarlo, \u00bfqu\u00e9 puedo hacer?","text":"<p>En programaci\u00f3n competitiva es normal encontrarse con problemas fuera de nuestra zona de comfort, problemas que nos superan, que nos frustran o, incluso a veces, deprimir. Problemas que nos hacen decir \"Oh, y ahora qui\u00e9n podr\u00e1 ayudarme?\". Para esos programadores desamparads hay buenas noticias: \u00a1existen muchas formas de recibir ayuda!</p> <p>Primero que todo, recordarles que los talleres son presenciales (3 m\u00f3dulos los d\u00edas viernes). Tanto el profesor como el ayudante estaremos f\u00edsicamente ah\u00ed presentes para que nos bombardeen con preguntas. Tanto c\u00f3digo como teor\u00eda, lo que sea. No tengan miedo, pregunten. Del mismo modo, tambi\u00e9n est\u00e1n sus compa\u00f1ers. En un curso siempre hay alumns m\u00e1s experimentads. Aprovechenls y h\u00e1ganles preguntas. Conversen. No es necesario estar toda la clase callad sin interactuar con nadie. La idea es que aprovechen la instancia presencial para discutir sobre los problemas con sus compa\u00f1ers y con el staff del curso.</p> <p>Sin embargo, sabemos que la timidez es un problema y no tods se sienten c\u00f3mods preguntando en persona, por lo cual tambi\u00e9n existen alternativas de ayuda remota:</p> <ul> <li>Telegram. Pueden hacer preguntas en el grupo de Telegram del curso. Si necesitan una ayuda m\u00e1s personalizada, Telegram tambi\u00e9n permite chatear directamente con personas (1 a 1), ya sea con el profesor, el ayudante o incluso con sus otros compa\u00f1ers m\u00e1s experimentads.</li> <li>Hints, explicaciones y soluciones de ejemplo. Todas las semanas tanto el profesor como el ayudante estaremos publicando hints, explicaciones y soluciones (c\u00f3digo) de ejemplo para la mayor\u00eda de los problemas de las competencias. Les iremos avisando de esto a lo largo del semestre.</li> <li>La p\u00e1gina del curso (i.e. esta p\u00e1gina), y en general, internet: Si te gusta m\u00e1s estudiar por cuenta propia, en esta p\u00e1gina encontrar\u00e1s mucho material de estudio disponible sobre distintos temas (adem\u00e1s de todo lo que puedas encontrar por tu cuenta en internet).</li> </ul>"},{"location":"tips/","title":"Tips para novat@s","text":""},{"location":"tips/#sobre-lenguajes-de-programacion","title":"Sobre lenguajes de programaci\u00f3n","text":"<p>En programaci\u00f3n competitiva el lenguaje m\u00e1s utilizado por lejos es C++ (y dentro de C++ generalmente se usa de C++11 para arriba). En segundo lugar se encuentra Java. Y hace muy poco se comenz\u00f3 a utilizar tambi\u00e9n Python. Sin embargo, lamentablemente la mayor\u00eda de los jueces online (los servidores que tienen los enunciados de los problemas y ejecutan los c\u00f3digos enviados por la gente) est\u00e1n calibrados generalmente para aceptar soluciones en C++, y a veces pasa que las soluciones en Python fallan con el famoso Time Limit Exceeded (TLE), debido a que Python por ser un lenguaje interpretado se ejecuta m\u00e1s lento que lenguajes compilados a c\u00f3digo de m\u00e1quina como C++. Adem\u00e1s, la mayor\u00eda de los c\u00f3digos de ejemplo disponibles en internet para progcomp est\u00e1n en C++ o quiz\u00e1 Java. Por este motivo, el consejo t\u00edpico es aprender C++. Si te motivas a seguir este consejo, en la secci\u00f3n para aprender C++ puedes encontrar bastante material para aprender. Dicho esto, que esto por favor no se malinterprete como que usar C++ es una obligaci\u00f3n. No, no. Si lo deseas, puedes usar Python, no hay ning\u00fan problema con eso. De hecho en muchos problemas las restricciones de tiempo son suficientemente holgadas y usar Python es perfectamente v\u00e1lido.</p> <p>El objetivo de este comentario es simplemente hacerte conciente de que al usar Python existe cierto riesgo de TLE por jueces \"pesados\" con restricciones de tiempo muy estrictas, y tambi\u00e9n que C++ es por lejos el lenguaje m\u00e1s popular en programaci\u00f3n competitiva. Si decides aprender C++, nuestro consejo es que vayas aprendiendo poco a poco, sin estresarte. Por ejemplo puedes ir intercalando entre C++ y Python. O puedes programar una soluci\u00f3n en Python y despu\u00e9s traducirla a C++, etc. Adem\u00e1s siempre estaremos subiendo ejemplos de soluciones en C++, y tanto el profesor como el ayudante estaremos disponibles para que nos hagas todas las consultas que necesites.</p>"},{"location":"tips/#sobre-restricciones-de-tiempo-y-memoria-en-programacion-competitiva","title":"Sobre restricciones de tiempo y memoria en programaci\u00f3n competitiva","text":"<ul> <li>En la ICPC y en la mayor\u00eda de los jueces online de entrenamiento los problemas tienen l\u00edmites de tiempo (ej. 3 segundos) y memoria (ej. 256 MB). Esto significa que soluciones muy lentas o soluciones que requieren anotar demasiadas cosas no funcionar\u00e1n.</li> <li>En C++ pueden hacerse un poco m\u00e1s de \\(10^8\\) operaciones baratas por segundo (una estimaci\u00f3n bien al ojo por experiencia con diferentes jueces online). Por lo tanto, si les dan \\(K\\) segundos de tiempo l\u00edmite, a lo m\u00e1s podr\u00e1n hacer un poco m\u00e1s de \\(K \\cdot 10^8\\) operaciones baratas. Tengan esto muy presente.</li> <li>MUY IMPORTANTE: ANTES DE TOCAR EL TECLADO, ANTES DE ESCRIBIR LA PRIMERA L\u00cdNEA DE C\u00d3DIGO, es sumamente importante estimar cu\u00e1nto se va a demorar la estrategia/algoritmo que quiero programar. Nadie quiere desperdiciar su tiempo programando una soluci\u00f3n que despu\u00e9s es muy lenta y nos da TLE (Time Limit Exceeded). Es por esto que siempre deben estimar la complejidad computacional de su algoritmo y evaluarla en el caso borde m\u00e1s grande (peor caso). Por ejemplo, si un problema depende de \\(N\\) donde \\(1 \\leq N \\leq 10^5\\) y mi algoritmo es cuadr\u00e1tico (complejidad \\(= \\mathcal{O}(N^2)\\)), entonces en el peor caso har\u00e9 \\((10^5)^2 = 10^{10}\\) operaciones, y por ende seg\u00fan el punto anterior necesitar\u00eda 100 segundos para correrlo. En cambio, si mi algoritmo tiene complejidad \\(\\mathcal{O}(N\\cdot\\log(N))\\) entonces en el peor caso s\u00f3lo har\u00e9 \\(10^5 \\cdot \\log(10^5) = 1.7 \\cdot 10^6\\) operaciones (aprox.), y por ende s\u00f3lo necesitar\u00eda \\(0.017\\) segundos (la nada misma) para correrlo. Entonces, si mi problema tiene un tiempo m\u00e1ximo de ejecuci\u00f3n de 2 segundos, \u00bfqu\u00e9 algoritmo va a funcionar? Claramente el segundo.</li> <li>Si van a usar mucha memoria, preoc\u00fapense de no pasarse del l\u00edmite de memoria permitido. Por ejemplo si les dan 256MB de memoria, en bytes eso es \\(256 \\cdot 1024 \\cdot 1024 = 268435456\\) bytes, un int32 ocupa 4 bytes, as\u00ed que como m\u00e1ximo podr\u00edan crear un arreglo de int32 de largo \\(67108864 = 6.7 \\cdot 10^7\\) aprox (o la mitad si usan un int64, un double, etc.). Tambi\u00e9n podr\u00eda acab\u00e1rseles la memoria si hacen demasiadas llamadas recursivas [1, 2].</li> </ul>"},{"location":"about/activities/","title":"C\u00f3mo funciona el curso","text":""},{"location":"about/activities/#1-competencias-semanales","title":"1) Competencias Semanales","text":"<p>Este curso es 100% pr\u00e1ctico. La nota final depender\u00e1 de la resoluci\u00f3n por parte del alumno de problemas de programaci\u00f3n competitiva. Cada semana se publicar\u00e1 un contest (o competencia, en espa\u00f1ol). Los contests se caracterizan por lo siguiente:</p> <ul> <li> <p>Se publicar\u00e1n en vjudge.net, un sitio web que permite crear competencias utilizando problemas obtenidos de m\u00faltiples jueces online, con un scoreboard que se actualiza en tiempo real a medida que los participantes resuelven problemas. Para competir es necesario que te crees una cuenta en vjudge.net y posteriormente que te unas con dicha cuenta a los contests a medida que estos vayan siendo publicados.</p> </li> <li> <p>A menos que se indique lo contrario, todas las competencias ser\u00e1n individuales. Excepcionalmente, hacia el final del semestre es posible que una que otra competencia sea de car\u00e1cter grupal, con un m\u00e1ximo de 3 integrantes por grupo (esto ser\u00e1 avisado si se llega a realizar).</p> </li> <li> <p>En general los contests ser\u00e1n tem\u00e1ticos. Es decir, cada contest estar\u00e1 compuesto por problemas que se resuelven utilizando estrategias pertenecientes a una categor\u00eda o tema com\u00fan (ej. fuerza bruta, geometr\u00eda, grafos, strings, etc.). El tema del contest se avisar\u00e1 con anticipaci\u00f3n junto con una recomendaci\u00f3n de material de estudio que los alumnos podr\u00e1n revisar antes de la clase.</p> </li> <li> <p>En general el primer m\u00f3dulo de cada clase (14:00 - 15:30) ser\u00e1 de c\u00e1tedra. La idea es revisar contenidos relevantes para el contest de la semana. Esto significa revisar la teor\u00eda, ver c\u00f3digos de ejemplo y quiz\u00e1 explicar la soluci\u00f3n de alg\u00fan problema que aparecer\u00e1 en el contest. Tambi\u00e9n es muy com\u00fan discutir soluciones de problemas del contest pasado en este bloque.</p> </li> <li> <p>El resto de la clase (15:30 en adelante) es pr\u00e1ctico. La idea es que durante los dos m\u00f3dulos restantes los alumnos trabajen en sus computadores programando. Por esto se recomienda que cada uno traiga su laptop a la clase. Si no tienes laptop, por favor avisa al staff del curso con anticipaci\u00f3n para poder coordinar laptops de repuesto. [Nota COVID: esto, obviamente, no aplica en formato de clase remoto]</p> </li> <li> <p>Salvo en contest grupales, cada alumn@ debe programar su propia soluci\u00f3n. Copiar c\u00f3digo ajeno est\u00e1 terminantemente prohibido. Sin embargo, s\u00ed est\u00e1 permitido conversar sobre los problemas, compartir ideas y discutir posibles soluciones con sus compa\u00f1er@s. Adem\u00e1s, tanto el profesor como el ayudante estamos disponibles para atender sus dudas y preguntas sobre los problemas, sobre c\u00f3digo, sobre teor\u00eda, etc.</p> </li> <li> <p>Los problemas de cada contest tendr\u00e1n diferentes niveles de dificultad, algunos problemas son m\u00e1s f\u00e1ciles y otros m\u00e1s dif\u00edciles. Por ende, cada problema tendr\u00e1 asociado un puntaje seg\u00fan su nivel de dificultad, y los puntos que obtengas en el contest ser\u00e1n la suma de los puntos de los problemas que resuelvas. Estos puntajes se mantendr\u00e1n intencionalmente ocultos por un par de d\u00edas luego de iniciado el contest :)</p> </li> <li> <p>Puntajes: regalado (1), f\u00e1cil (2), medio-f\u00e1cil (3), medio (4), medio-dif\u00edcil (5), dif\u00edcil (6), muy dif\u00edcil (7), demasiado dif\u00edcil (8 o m\u00e1s)</p> </li> <li> <p>Cada contest tendr\u00e1 un puntaje m\u00ednimo esperado, si en el contest logras un puntaje \\(\\geq\\) a dicho m\u00ednimo obtienes un 100% de completado en el contest, de lo contrario obtienes un porcentaje inferior y una deuda de puntaje. Todas las deudas de puntaje de todos tus contests se suman y conforman tu deuda de puntaje total. No obstante, si tu puntaje para un contest supera el m\u00ednimo esperado, se genera un excedente de puntaje, y del mismo modo todos tus excedentes se suman y conforman tu excedente de puntaje total. Como es de esperar, el excedente de puntaje te puede ayudar a compensar tu deuda de puntaje y subir tu nota, aunque ten en cuenta que el excedente de puntaje es multiplicado por un coeficiente de 0.3.</p> </li> <li> <p>vjudge permite enviar soluciones en modo post-competencia. Si lo deseas puedes seguir resolviendo problemas en este modo luego del fin de un contest, aunque todos los puntos de los problemas que resuelvas as\u00ed van directo a tu excedente de puntaje, y por ende ser\u00e1n multiplicados por 0.3 (en otras palabras, rinde m\u00e1s resolver problemas dentro de plazo que fuera de plazo)</p> </li> </ul>"},{"location":"about/activities/#2-asistencia","title":"2) Asistencia","text":"<p>Para fomentar la participaci\u00f3n y asistencia a clases, este curso incluye nota por asistencia, la cual corresponde al 25% de la nota del curso. Para quedar presente eso s\u00ed s\u00f3lo basta con que vengas a un modulo, no es necesario que est\u00e9s presente toda la clase, aunque si pudieras quedarte los 3 m\u00f3dulos ser\u00eda estupendo!</p> <p>En caso de inasistencia, existe la posibilidad de recuperar (parcial o totalmente) la asistencia de ese d\u00eda haciendo m\u00e1s problemas del contest respectivo. Para este efecto, vamos a considerar que una asistencia vale 3 puntos. Si faltas a una clase pero en el contest respectivo tu excedente de puntaje es mayor o igual a 3, se considerar\u00e1 como si hubieras asistido (obviamente, esos 3 puntos no se contabilizar\u00e1n en tu excedente de puntaje total). En cambio, si tu excedente de puntaje es menor a 3, la asistencia se recuperar\u00e1 s\u00f3lo \"parcialmente\". En otras palabras, los que lo deseen pueden hacer el curso entero desde la casa, pero tendr\u00e1n que programar m\u00e1s :)</p> <p>Adem\u00e1s, se perdonar\u00e1n 2 inasistencias. Es decir, puedes faltar a dos clases sin necesidad de recuperar la asistencia y tu nota no ser\u00e1 afectada.</p>"},{"location":"about/activities/#3-bonuses","title":"3) Bonuses","text":"<p>Adem\u00e1s de las competencias semanales, existen varias formas de obtener d\u00e9cimas de bonus, las que se ponderar\u00e1n y sumar\u00e1n directamente a tu nota final:</p>"},{"location":"about/activities/#31-bonus-c","title":"3.1) BONUS C++","text":"<p>Bonus para incentivar el uso de C++ (el lenguaje m\u00e1s popular en progcomp). \u00bfC\u00f3mo obtener este bonus?</p> <ul> <li>Primero que todo, este bonus es v\u00e1lido s\u00f3lo para gente sin (o con demasiada poca) experiencia previa programando en C++. Si ya tienes experiencia en C++ (o en C, que es muy parecido), este bonus no es para ti.</li> <li>Para obtener este bonus, en alg\u00fan momento durante el semestre debes avisarnos que quieres cobrar este bonus. Debes indicarnos los contests y respectivos problemas que has hecho en C++. Nosotros revisaremos tus c\u00f3digos. Para obtener el 100% del bonus, se debe notar un dominio progresivo de C++ en tus c\u00f3digos. Haber logrado resolver al menos un problema complicado en C++ es un plus.</li> <li>Puedes obtener hasta un m\u00e1ximo de 10 d\u00e9cimas con este bonus.</li> <li>Este bonus s\u00f3lo puede ser cobrado una vez en todo el semestre (una posibilidad es esperar hasta el final del semestre y ah\u00ed reci\u00e9n cobrarlo).</li> <li>Si quieres aprender C++, puedes encontrar hartos recursos ac\u00e1.</li> </ul>"},{"location":"about/activities/#32-bonus-rpc-grupal","title":"3.2) BONUS RPC (grupal)","text":"<p>Cada cierto tiempo la Red de Programaci\u00f3n Competitiva (RPC) organiza competencias de entrenamiento. El calendario y registro para estas competencias se encuentran ac\u00e1: http://registro.redprogramacioncompetitiva.com/contests, y los scoreboards de las competencias pasadas se pueden encontrar ac\u00e1: http://redprogramacioncompetitiva.com/Contest. N\u00f3tese que se trata de un bonus grupal, por ende para obtener este bonus deben:</p> <ul> <li>Registrarse en una competencia en grupos de 2 o 3 alumn@s.</li> <li>Participar en la competencia</li> <li>Mandar una foto del grupo con todos sus integrantes juntos frente a un mismo computador (necesitamos evidencia de que se juntaron, y adem\u00e1s la idea es que sea lo m\u00e1s parecido a un simulacro de la ICPC, donde los 3 integrantes comparten un mismo PC, como en este ejemplo). [Nota COVID: en caso de pandemia, se acepta un screenshot de zoom, skype, etc.]</li> <li>Al terminar la competencia, deben mandar el link al scoreboard final de la competencia RPC en que participaron.</li> <li>El bonus se calcular\u00e1 como \\(5 \\cdot \\frac{X}{N}\\) d\u00e9cimas, donde \\(X =\\) problemas resueltos por el grupo, \\(N =\\) problemas resueltos por el equipo que qued\u00f3 en primer lugar. Las \\(5 \\cdot \\frac{X}{N}\\) d\u00e9cimas obtenidas se sumar\u00e1n a las d\u00e9cimas de bonus de cada integrante del equipo.</li> </ul>"},{"location":"about/activities/#33-bonus-contest-individual","title":"3.3) BONUS Contest Individual","text":"<p>Existen muchos sitios online que organizan competencias individuales cada cierto tiempo. Los alumnos tienen la opci\u00f3n de participar en estas competencias y obtener d\u00e9cimas de bonus. Los sitios que m\u00e1s recomendamos son Codeforces, Atcoder y Codechef. Todos tienen calendarios: calendario codeforces, calendario atcoder, calendario codechef. Para obtener este bonus debes:</p> <ul> <li>Registrarte en Codeforces, Atcoder y/o Codechef.</li> <li>Participar en una competencia individual (generalmente duran alrededor de 2 horas).</li> <li>Al final de la competencia avisarnos en qu\u00e9 competencia participaste y mandar el link al ranking donde quedaste.</li> <li>El bonus se calcular\u00e1 como \\(3 \\cdot \\frac{X}{N}\\) d\u00e9cimas, donde \\(X =\\) cantidad de problemas resueltos por ti, \\(N =\\) cantidad de problemas resueltos por la persona que qued\u00f3 en primer lugar. Las \\(3 \\cdot \\frac{X}{N}\\) d\u00e9cimas obtenidas se sumar\u00e1n a tus d\u00e9cimas de bonus.</li> </ul>"},{"location":"about/activities/#34-bonus-prohibido-codeforces","title":"3.4) BONUS PROHIBIDO Codeforces","text":"<p>Codeforces tiene un sistema de rating parecido al ELO en Ajedrez. Cualquier alumn que participe en al menos 3 contests de Codeforces durante el semestre y luego de ello alcance un rating de 1200 o superior, puedes reclamar un bonus de \\(\\frac{\\textsf{rating_alcanzado} - 1200}{10}\\) d\u00e9cimas a la nota final del curso. Por ejemplo, si participas en tres contests durante el semestre y logras un rating de 1350, tienes autom\u00e1ticamente 1,5 puntos extra a la nota final.</p>"},{"location":"about/grading/","title":"C\u00e1lculo de la Nota Final","text":"<ul> <li>Sea \\(P_i =\\) total puntos por problemas resueltos dentro de plazo en el contest \\(i\\)-\u00e9simo</li> <li>Sea \\(T_i =\\) total puntos por problemas resueltos fuera de plazo en el contest \\(i\\)-\u00e9simo</li> <li>Sea \\(M_i =\\) puntaje m\u00ednimo esperado para el contest \\(i\\)-\u00e9simo</li> <li>Sea \\(A_i = 1\\) si viniste a clases para el contest \\(i\\)-\u00e9simo, \\(0\\) si no</li> <li>Sea \\(N =\\) n\u00famero de contests</li> </ul> <p>As\u00ed, se calcula:</p> <ul> <li>\\(D_i = \\max(M_i - P_i, 0) =\\) deuda de puntaje del contest \\(i\\)-\u00e9simo</li> <li>\\(PA_i = 3\\) si vienes a clase, \\(\\max(0, \\min(3, P_i - M_i))\\) si no vienes</li> <li>\\(E_i = \\max(P_i - M_i, 0) + T_i - (1-A_i) \\cdot PA_i =\\) excedente de puntaje del contest \\(i\\)-\u00e9simo, considerando posible descuento por inasistencia</li> <li>\\(X_i = 1 - \\frac{D_i}{M_i} =\\) fracci\u00f3n completada del m\u00ednimo esperado para el contest \\(i\\)-\u00e9simo</li> <li>\\(D =\\) suma de todos los \\(D_i\\)</li> <li>\\(E =\\) suma de todos los \\(E_i\\)</li> <li>\\(X =\\) promedio de todos los \\(X_i\\)</li> <li>\\(A = \\frac{\\min(1, \\sum PA_i)}{(3 \\cdot (N-2))}\\), el \\(-2\\) considera dos d\u00edas de inasistencia perdonados</li> </ul> <p>As\u00ed, \\(E\\) se usa para reducir la deuda \\(D\\) de la siguiente manera:</p> <ul> <li>\\(D' = \\max(D - E \\cdot 0.3, 0)\\)</li> <li>\\(X' = X + (1-X) \\cdot \\frac{(D-D')}{D}\\)</li> </ul> <p>As\u00ed, se obtiene una nota preliminar</p> <ul> <li>\\(\\operatorname{Nota}_{V1} = (1 + 6 \\cdot X') \\cdot 0.75 + (1 + 6 \\cdot A) \\cdot 0.25\\)</li> </ul> <p>Sin embargo, luego se bajar\u00e1 la escala del curso, es decir, si ning\u00fan alumno alcanz\u00f3 el \\(7\\), el alumno con mayor nota quedar\u00e1 con \\(7\\) (siempre y cuando la escala baje \"poco\" - i.e. habr\u00e1 un l\u00edmite para bajar la escala con el fin de prevenir \"hacks\" al sistema).</p> <ul> <li>\\(\\operatorname{Nota}_{V2} =\\) aplicar_escala_reducida(\\(\\operatorname{Nota}_{V1}\\))</li> </ul> <p>Luego se calcula las d\u00e9cimas de bonus efectivas:</p> <ul> <li>\\(B = (BCpp + BRPC + BCI) \\cdot \\frac{(\\operatorname{Nota}_{V1} - 1)}{6}\\)</li> </ul> <p>Finalmente, la nota final est\u00e1 dada por:</p> <ul> <li>\\(\\operatorname{Nota}_{V3} = \\operatorname{Nota}_{V2} + B\\)</li> </ul> <p>Todo lo anterior se encuentra formalizado en el spreadsheet de notas y asistencia: link</p>"},{"location":"about/introduction/","title":"Introducci\u00f3n","text":"<p>Este es un curso pr\u00e1ctico que prepara a los estudiantes para resolver problemas algor\u00edtmicos de programaci\u00f3n competitiva, como los que aparecen en competencias como la ICPC, Google CodeJam, Facebook Hacker Cup y similares a los que preguntan empresas como Amazon y Google en sus entrevistas de trabajo. Los estudiantes ejercitar\u00e1n sus conocimientos de estructuras de datos y algoritmos, su ingenio y sus habilidades de programaci\u00f3n mediante la resoluci\u00f3n semanal de problemas de programaci\u00f3n competitiva.</p> <p>Al tratarse de un curso pr\u00e1ctico, la mayor\u00eda de tu tiempo te la pasar\u00e1s programando. No obstante, las habilidades que adquirir\u00e1s ac\u00e1 van m\u00e1s all\u00e1 que simplemente ganar competencias:</p> <ul> <li>Repasar\u00e1s, expandir\u00e1s y profundizar\u00e1s tus conocimientos en estructuras de datos y algoritmos.</li> <li>Te volver\u00e1s un programador o programadora mucho m\u00e1s cuidados y precis. Desarrollar\u00e1s el h\u00e1bito de considerar siempre los l\u00edmites de tiempo y memoria al escribir tus c\u00f3digos, as\u00ed como estar siempre preocupad de los casos bordes.</li> <li>Ejercitar\u00e1s tus habilidades de debugging, y m\u00e1s importante a\u00fan, aprender\u00e1s a identificar cu\u00e1ndo hay riesgo de bugs y c\u00f3mo escribir buenos c\u00f3digos que permitan prevenirlos.</li> <li>Ejercitar\u00e1s la habilidad de pensar creativamente antes de programar. Con el tiempo ver\u00e1s c\u00f3mo los problemas te obligar\u00e1n a pensar de forma ingeniosa y creativa para dise\u00f1ar soluciones eficientes y correctas, que cumplan con todas las restricciones.</li> </ul> <p>Todas estas habilidades son sumamente \u00fatiles no solo aqu\u00ed sino tambi\u00e9n en los dem\u00e1s cursos de la malla de Ciencia de Computaci\u00f3n, adem\u00e1s de ser ampliamente valoradas y buscadas por empresas de la industria de software (ej. Google, Facebook, Microsoft) y a la larga muy \u00fatiles en tu carrera profesional.</p>"},{"location":"about/syllabus/","title":"Temario tentativo","text":""},{"location":"about/syllabus/#introduccion-a-la-programacion-competitiva-2-semanas","title":"Introducci\u00f3n a la Programaci\u00f3n Competitiva (2 semanas)","text":"<ul> <li>Introducci\u00f3n a Complejidad Computacional</li> <li>Problemas f\u00e1ciles e introductorios de implementaci\u00f3n</li> </ul>"},{"location":"about/syllabus/#busqueda-binaria-y-ternaria-2-semanas","title":"B\u00fasqueda Binaria y Ternaria (2 semanas)","text":""},{"location":"about/syllabus/#fuerza-bruta-y-backtracking-1-semana","title":"Fuerza Bruta y Backtracking (1 semana)","text":""},{"location":"about/syllabus/#problemas-interactivos-1-semanas","title":"Problemas Interactivos (1 semanas)","text":""},{"location":"about/syllabus/#programacion-dinamica-2-semanas","title":"Programaci\u00f3n Din\u00e1mica (2 semanas)","text":""},{"location":"about/syllabus/#algoritmos-codiciosos-1-semana","title":"Algoritmos Codiciosos (1 semana)","text":""},{"location":"about/syllabus/#introduccion-a-grafos-2-semana","title":"Introducci\u00f3n a Grafos (2 semana)","text":"<ul> <li>Conceptos b\u00e1sicos: grafos dirigidos, no dirigido, \u00e1rboles.</li> <li>C\u00f3mo representar grafos en c\u00f3digo.</li> <li>Recorriendo grafos: DFS y BFS.</li> <li>Camino m\u00e1s corto: Dijkstra, Bellman-Ford y Floyd-Warshall</li> </ul>"},{"location":"about/syllabus/#matematicas-y-teoria-de-numeros-resto-del-semestre","title":"Matem\u00e1ticas y Teor\u00eda de N\u00fameros (resto del semestre)","text":"<ul> <li>N\u00fameros primos</li> <li>Aritm\u00e9tica modular</li> <li>Exponenciaci\u00f3n binaria</li> <li>Conteo y combinatoria</li> <li>Teorema del resto chino</li> </ul>"},{"location":"contests/","title":"Contests","text":""},{"location":"contests/#contest-1","title":"Contest 1","text":"<p>Marzo 10, 14 d\u00edas, link a contest</p> <p>T\u00f3picos: Introducci\u00f3n a programaci\u00f3n competitiva Puntos:</p> Problema <code>A</code> <code>B</code> <code>C</code> <code>D</code> <code>E</code> <code>F</code> <code>G</code> <code>H</code> <code>I</code> <code>J</code> Puntaje 1 2 2 2 3 3 3 3 4 2 <p>Puntaje M\u00ednimo Esperado: 5</p> <p>Hints y c\u00f3digos de ejemplo: link</p>"},{"location":"contests/#contest-2","title":"Contest 2","text":"<p>Marzo 17, 14 d\u00edas, link a contest</p> <p>T\u00f3picos: Introducci\u00f3n a programaci\u00f3n competitiva Puntos:</p> Problema <code>A</code> <code>B</code> <code>C</code> <code>D</code> <code>E</code> <code>F</code> <code>G</code> <code>H</code> <code>I</code> <code>J</code> Puntaje 2 2 1 2 3 2 3 3 3 4 <p>Puntaje M\u00ednimo Esperado: 5</p> <p>Hints y c\u00f3digos de ejemplo: link</p>"},{"location":"contests/#contest-3","title":"Contest 3","text":"<p>Marzo 24, 21 d\u00edas, link a contest</p> <p>T\u00f3picos: Intro a complejidad computacional y b\u00fasqueda binaria Puntos:</p> Problema <code>A</code> <code>B</code> <code>C</code> <code>D</code> <code>E</code> <code>F</code> <code>G</code> <code>H</code> <code>I</code> <code>J</code> Puntaje 2 2 2 2 2 2 4 3 3 4 <p>Puntaje M\u00ednimo Esperado: 6</p> <p>Hints y c\u00f3digos de ejemplo: link</p>"},{"location":"contests/#contest-4","title":"Contest 4","text":"<p>Marzo 31, 21 d\u00edas, link a contest</p> <p>T\u00f3picos: Busqueda binaria y ternaria Puntos:</p> Problema <code>A</code> <code>B</code> <code>C</code> <code>D</code> <code>E</code> <code>F</code> <code>G</code> <code>H</code> Puntaje 3 2 4 5 3 3 3 3 <p>Puntaje M\u00ednimo Esperado: 5</p> <p>Hints y c\u00f3digos de ejemplo: Pronto.</p>"},{"location":"contests/#contest-5","title":"Contest 5","text":"<p>Abril 14, 14 d\u00edas, link a contest</p> <p>T\u00f3picos: Fuerza bruta y backtracking Puntos:</p> Problema <code>A</code> <code>B</code> <code>C</code> <code>D</code> <code>E</code> <code>F</code> <code>G</code> <code>H</code> <code>I</code> Puntaje 4 3 3 3 4 3 3 4 5 <p>Puntaje M\u00ednimo Esperado: 5</p> <p>Hints y c\u00f3digos de ejemplo: Pronto.</p>"},{"location":"contests/#contest-6","title":"Contest 6","text":"<p>Abril 21, 21 d\u00edas, link a contest</p> <p>T\u00f3picos: Greedy Puntos:</p> Problema <code>A</code> <code>B</code> <code>C</code> <code>D</code> <code>E</code> <code>F</code> <code>G</code> <code>H</code> <code>I</code> <code>J</code> Puntaje 2 2 4 2 3 4 4 3 3 4 <p>Puntaje M\u00ednimo Esperado: 5</p> <p>Hints y c\u00f3digos de ejemplo: Pronto.</p>"},{"location":"contests/#contest-7","title":"Contest 7","text":"<p>Abril 28, 21 d\u00edas, link a contest</p> <p>T\u00f3picos: Repaso/Problemas cl\u00e1sicos Puntos:</p> Problema <code>A</code> <code>B</code> <code>C</code> <code>D</code> <code>E</code> <code>F</code> <code>G</code> <code>H</code> <code>I</code> <code>J</code> Puntaje 2 2 3 2 2 3 3 3 4 4 <p>Puntaje M\u00ednimo Esperado: 6</p> <p>Hints y c\u00f3digos de ejemplo: Pronto.</p>"},{"location":"contests/#contest-8","title":"Contest 8","text":"<p>Mayo 12, 14 d\u00edas, link a contest</p> <p>T\u00f3picos: Programaci\u00f3n din\u00e1mica Puntos:</p> Problema <code>A</code> <code>B</code> <code>C</code> <code>D</code> <code>E</code> <code>F</code> <code>G</code> <code>H</code> <code>I</code> <code>J</code> Puntaje X X X X X X X X X X <p>Puntaje M\u00ednimo Esperado: -</p> <p>Hints y c\u00f3digos de ejemplo: Pronto.</p>"},{"location":"contests/#contest-9","title":"Contest 9","text":"<p>Mayo 19, 14 d\u00edas, link a contest</p> <p>T\u00f3picos: Greedy o programaci\u00f3n din\u00e1mica (o ninguna) Puntos:</p> Problema <code>A</code> <code>B</code> <code>C</code> <code>D</code> <code>E</code> <code>F</code> <code>G</code> <code>H</code> <code>I</code> <code>J</code> Puntaje X X X X X X X X X X <p>Puntaje M\u00ednimo Esperado: -</p> <p>Hints y c\u00f3digos de ejemplo: Pronto.</p>"},{"location":"contests/#contest-10","title":"Contest 10","text":"<p>Mayo 26, 14 d\u00edas, link a contest</p> <p>T\u00f3picos: Problemas Interactivos Puntos:</p> Problema <code>A</code> <code>B</code> <code>C</code> <code>D</code> <code>E</code> <code>F</code> <code>G</code> <code>H</code> <code>I</code> <code>J</code> Puntaje X X X X X X X X X X <p>Puntaje M\u00ednimo Esperado: -</p> <p>Hints y c\u00f3digos de ejemplo: Pronto.</p>"},{"location":"contests/hints/contest1/","title":"Contest 1 - hints y c\u00f3digos de ejemplo","text":""},{"location":"contests/hints/contest1/#a-watermelon","title":"A - Watermelon","text":"Hint    Lo vimos en clases."},{"location":"contests/hints/contest1/#b-stones-on-the-table","title":"B - Stones on the Table","text":"Hint    Basta recorrer el string y sumar uno a la respuesta cada vez que una letra sea igual a la anterior"},{"location":"contests/hints/contest1/#c-sum-of-the-others","title":"C - Sum of the Others","text":"Hint    Piensen en cuanto debe ser la suma de todo (incluyendo el resultado) si el resultado es igual a la suma"},{"location":"contests/hints/contest1/#d-temporarily-unavailable","title":"D - Temporarily unavailable","text":"Hint    Podemos chequear si no hay intersecci\u00f3n y retornar 0 (basta ver si el comienzo de cobertura esta despu\u00e9s del final del recorrido o si el final del radio de cobertura est\u00e1 antes del inicio del recorrido), en otro caso basta sumar el tama\u00f1o del principio al comienzo del radio de cobertura y del final del radio de cobertura hasta el final del recorrido (si son positivos)."},{"location":"contests/hints/contest1/#e-h-index","title":"E - H-Index","text":"Hint    Se debe encontrar el mayor H tal que tenemos al menos H papers con al menos H citas. Para esto piensen c\u00f3mo facilita el c\u00e1lculo ordenar las citas de cada paper de mayor a menor. Ojo que no se puede resolver viendo todas las posibilidades de H y chequeando porque no pasa en el tiempo l\u00edmite."},{"location":"contests/hints/contest1/#f-four-segments","title":"F - Four Segments","text":"Hint    Busque caracter\u00edsticas necesarias y suficientes para determinar que los segmentos entregados forman un rect\u00e1ngulo, por ejemplo, hay exactamente 4 puntos y 4 segmentos, 2 verticales y 2 horizontales."},{"location":"contests/hints/contest1/#g-touchscreen-keyboard","title":"G - Touchscreen Keyboard","text":"Hint    Podemos asignarles coordenadas de fila y columna a cada letra. Usando esto es f\u00e1cil obterner la soluci\u00f3n calculando distancias y ordenando. Pueden guardar las coordenadas en un diccionario de python o en un map de c++."},{"location":"contests/hints/contest1/#h-adding-words","title":"H - Adding Words","text":"Hint    Pueden usar diccionarios de Python o maps de c++ para asignar valores a las palabras y palabras a los valores. Usando esto piensen en c\u00f3mo implementar el resto."},{"location":"contests/hints/contest1/#i-they-are-everywhere","title":"I - They Are Everywhere","text":"Hint    Hay varias formas de hacerlo, una de las m\u00e1s simple consiste en mantener un rango en que est\u00e1n presentes todos los pokemons para cada posici\u00f3n final. Empezando de la primera posici\u00f3n en que est\u00e9n todos los pokemons hacia la izquierda, si avanzamos el borde derecho en una posici\u00f3n podemos mover el izquierdo mientras la ocurrencia del pokemon en el borde izquierdo dentro del rango sea mayor a 1. La respuesta final ser\u00e1 el m\u00ednimo de estos rangos. Est\u00e1 t\u00e9cnica es una aplicaci\u00f3n de dos punteros y es un enfoque bastante usado en programaci\u00f3n competitiva."},{"location":"contests/hints/contest1/#j-problema-horrible-1","title":"J - Problema Horrible 1","text":"Hint    Basta implementar lo descrito en el enunciado. Cuidado con los casos especiales de alineamiento, si hay una cantidad impar de espacio, se da menos espacio a la izquierda primero, la pr\u00f3xima vez con espacios impares a la derecha y as\u00ed."},{"location":"contests/hints/contest2/","title":"Contest 2 - hints y c\u00f3digos de ejemplo","text":""},{"location":"contests/hints/contest2/#a-reversed-binary-numbers","title":"A - Reversed Binary Numbers","text":"Hint    Si bien en python hay funciones que entregan la representaci\u00f3n binaria de un n\u00famero, traten de construirla, recuerden los operadores bitwise vistos en la clase."},{"location":"contests/hints/contest2/#b-two-distinct-points","title":"B - Two distinct points","text":"Hint    Basta con elegir un n\u00famero cualquiera del primer segmento y para el segundo elegir alguno de los v\u00e9rtices, mientras sea distinto al punto elegido para el primer segmento."},{"location":"contests/hints/contest2/#c-evening-out-1","title":"C - Evening Out 1","text":"Hint    Piensen en como usar el resto de A dividido B (A % B)."},{"location":"contests/hints/contest2/#d-remove-smallest","title":"D - Remove Smallest","text":"Hint    Piensen en c\u00f3mo lo har\u00edan si el arreglo estuviera ordenado de mayor a menor."},{"location":"contests/hints/contest2/#e-pizza-hawaii","title":"E - Pizza Hawaii","text":"Hint    Podemos guardar en diccionarios/maps para cada ingrediente en qu\u00e9 recetas aparece."},{"location":"contests/hints/contest2/#f-chocolate-division","title":"F - Chocolate Division","text":"Hint    Busquen una invariante en cuanto a la paridad de los turnos, dependiendo s\u00f3lo de R y C."},{"location":"contests/hints/contest2/#g-zagrade","title":"G - Zagrade","text":"Hint    Primero debemos obtener una lista de pares de indices correspondientes a pares de par\u00e9ntesis correlacionados. Para esto basta leer el string dado de izquierda a derecha y tener una lista de posiciones de abre par\u00e9ntes\u00eds a\u00fan no acoplados, cada vez que encontremos un cierra par\u00e9ntesis lo acoplamos con el \u00faltimo abre par\u00e9ntesis en la lista (y lo quitamos de la lista). Usando esto s\u00f3lo tenemos que ver todas las combinaciones de pares de par\u00e9ntesis a eliminar, armar los strings respectivos y ordenar la lista de respuestas."},{"location":"contests/hints/contest2/#h-sum","title":"H - Sum","text":"Hint    Primero debemos encontrar una base que genere el mayor largo en la suma, una base que siempre sirve para esto es el mayor d\u00edgito que nos dieron en el input + 1."},{"location":"contests/hints/contest2/#i-making-sequences-is-fun","title":"I - Making Sequences is Fun","text":"Hint    Podemos ir agregando los n\u00fameros de n d\u00edgitos en bloques mientras sea posible, empezando con n = #(d\u00edgitos en m). la cantidad de n\u00fameros con n d\u00edgitos que se pueden agregar en un principio es (10^n - m) sumamos eso a la respuesta, updateamos m a 10^n, sumamos uno a n y repetimos mientras no nos pasemos de w."},{"location":"contests/hints/contest2/#j-hyperset","title":"J - Hyperset","text":"Hint    Podemos recorrer cada par de string en el input en O(N^2), para cada par podemos determinar \u00fanicamente cu\u00e1l ser\u00eda el tercero que armar\u00eda un set con estos, por cada caracter si son iguales el tercero debe ser igual y si son distintos el tercero debe tener el que falta, luego basta chequear si el string armado estaba en el input (esto se puede hacer r\u00e1pido con un set). La complejidad si es bien implementado de esta soluci\u00f3n es de O(k * N^2 * log(N)) que pasa en el tiempo."},{"location":"contests/hints/contest3/","title":"Contest 3 - hints y c\u00f3digos de ejemplo","text":""},{"location":"contests/hints/contest3/#a-ehab-is-an-odd-person","title":"A - Ehab Is an Odd Person","text":"Hint    Todo depende de si hay al menos un n\u00famero de paridad distinta al resto."},{"location":"contests/hints/contest3/#b-positive-divisors","title":"B - Positive Divisors","text":"Hint    Notemos que si x divide a N entonces o x &lt; sqrt(N) o N/x &lt; sqrt(N). Luego basta revisar los divisores &lt;= sqrt(N)."},{"location":"contests/hints/contest3/#c-cumulative-sum-query","title":"C - Cumulative Sum Query","text":"Hint    Piensen en como usar un arreglo de sumas acumuladas, es decir, u arreglo A donde A[i] guarde la suma de los primeros i valores."},{"location":"contests/hints/contest3/#d-massive-card-game","title":"D - Massive Card Game","text":"Hint    Primero ordenemos el arreglo, luego podemos usar 2 b\u00fasquedas binarias, ver los problemas E y F como primer paso."},{"location":"contests/hints/contest3/#e-busqueda-binaria","title":"E - B\u00fasqueda Binaria","text":"Hint    Implementaci\u00f3n 101 de b\u00fasqueda binaria lower bound, pueden buscar ejemplos de implementaci\u00f3n adicional en materiales del curso."},{"location":"contests/hints/contest3/#f-busqueda-binaria-2","title":"F - B\u00fasqueda Binaria 2","text":"Hint    Implementaci\u00f3n 101 de b\u00fasqueda binaria upper bound, pueden buscar ejemplos de implementaci\u00f3n adicional en materiales del curso."},{"location":"contests/hints/contest3/#g-berland-collider","title":"G - Berland collider","text":"Hint    Deben hacer b\u00fasqueda binaria decimal en el tiempo, para esto deben poder checkear dado un tiempo si es que ha habido un choque hasta ese momento. Piensen en c\u00f3mo chequear eso."},{"location":"contests/hints/contest3/#h-vanya-and-lanterns","title":"H - Vanya and Lanterns","text":"Hint    Si usamos b\u00fasqueda binaria para encontrar el radio pedido, debemos pensar en un predicado que dado un radio nos diga si es suficiente para cubrir el camino o no. Pueden chequear esto linealmente recorriendo las l\u00e1mparas y marcando recordando la m\u00e1xima coordenada iluminada hacia la derecha, si en alg\u00fan punto el radio hacia la izquierda no alcanza la coordenada recordada hasta el paso anterior, entonces no cubre todo el camino. Ojo con que la coordenada recordada empieza siendo 0 y que al final deben chequear que se llegue al largo final del camino."},{"location":"contests/hints/contest3/#i-need-for-speed","title":"I - Need for Speed","text":"Hint    Si usamos b\u00fasqueda binaria para encontrar el c pedido, debemos pensar en un predicado que dado un c nos diga si el tiempo que toma es menor o no al tiempo que sabemos que demora el camino. En caso de ser menor necesitamos un c m\u00e1s peque\u00f1o y viceversa. Piensen en c\u00f3mo calculan el tiempo que demorar\u00eda el camino dado un c."},{"location":"contests/hints/contest3/#j-the-meeting-place-cannot-be-changed","title":"J - The Meeting Place Cannot Be Changed","text":"Hint    Si usamos b\u00fasqueda binaria para poder calcular el menor tiempo necesario para juntarse, debemos generar un predicado que dado un tiempo t nos diga si es posible juntarse o no en ese tiempo. Para esto usen que cada persona i en un tiempo t puede llegar a cualquier punto en un rango (x[i] - v[i] * t, x[i] + v[i] * t)."},{"location":"notes/geometry/base_implementation/","title":"Implementaci\u00f3n Base","text":"<p>Para trabajar con puntos, vectores, pol\u00edgonos, etc en programaci\u00f3n competitiva vamos a crear una estructura propia basada en la del libro Handbook of geometry for competitive programmers.</p>"},{"location":"notes/geometry/base_implementation/#operaciones-basicas","title":"Operaciones b\u00e1sicas","text":"<p>Partimos definiendo la estructura con la que vamos a trabajar y unas operaciones b\u00e1sicas.</p> <p> </p> <pre><code>typedef double T;   // (1)!\nstruct pt {\nT x,y;\npt operator+(pt p) {return {x+p.x, y+p.y};}\npt operator-(pt p) {return {x-p.x, y-p.y};}\npt operator*(T d) {return {x*d, y*d};}\npt operator/(T d) {return {x/d, y/d};}\n};\n</code></pre> <ol> <li> Se puede cambiar por <code>int</code> o <code>long long</code> seg\u00fan sea necesario.</li> </ol> <p>Entonces, podemos crear puntos y operar de la siguiente forma:</p> <p> </p> <pre><code>pt a = {1, 2};   // (1)!\npt b = {3, 4};\npt c = a + b; // {4, 6}\npt d = a - b; // {-2, -2}\npt e = a * 2; // {2, 4}\npt f = a / 2; // {0.5, 1}\n/*(2)!/*\n</code></pre> <ol> <li> As\u00ed se creamos un punto. </li> <li> Nuestra implementaci\u00f3n nos permite operar de forma intuitiva. </li> </ol>"},{"location":"notes/geometry/base_implementation/#operadores-de-comparacion","title":"Operadores de comparaci\u00f3n","text":"<p>Como no hay un orden natural para los puntos, vamos a s\u00f3lo diferenciar cuando son iguales o no.</p> <p> </p> <pre><code>bool operator==(pt a, pt b) {return a.x == b.x &amp;&amp; a.y == b.y;}\nbool operator!=(pt a, pt b) {return !(a == b);}\n</code></pre>"},{"location":"notes/geometry/base_implementation/#imprimir-puntos","title":"Imprimir puntos","text":"<p>Para imprimir un punto, vamos a usar definir el operador <code>&lt;&lt;</code> para que imprima <code>(x,y)</code>.</p> <p> </p> <pre><code>ostream&amp; operator&lt;&lt;(ostream&amp; os, pt p) {\nreturn os &lt;&lt; \"(\"&lt;&lt; p.x &lt;&lt; \",\" &lt;&lt; p.y &lt;&lt; \")\";\n}\n</code></pre> <p>Entonces podemos imprimir un punto de la siguiente forma:</p> <p> </p> <pre><code>pt a{3,4}, b{2,-1};\ncout &lt;&lt; a+b &lt;&lt; \" \" &lt;&lt; a-b &lt;&lt; \"\\n\"; // (5,3) (1,5)\ncout &lt;&lt; a*-1 &lt;&lt; \" \" &lt;&lt; b/2 &lt;&lt; \"\\n\"; // (-3,-4) (1.5,2)\n</code></pre>"},{"location":"notes/geometry/base_implementation/#distancia-entre-puntos","title":"Distancia entre puntos","text":"<p>Para calcular la distancia entre dos puntos, vamos a usar la f\u00f3rmula de la distancia euclidiana. Primero definimos la norma de un punto:</p> <p> </p> <pre><code>T sq(pt p) {return p.x*p.x + p.y*p.y;}\ndouble abs(pt p) {return sqrt(sq(p));}\n</code></pre> <p>Ahora podemos calcular la distancia entre dos puntos:</p> <p> </p> <pre><code>double dist(pt a, pt b) {return abs(a-b);}\n</code></pre>"},{"location":"notes/geometry/base_implementation/#conclusiones","title":"Conclusiones","text":"<p>Lo presentado en esta entrada es una breve implementaci\u00f3n de una estrucutra de puntos que nos ayudar\u00e1 a manejarlos de forma m\u00e1s fluida. En contraste a ocupar <code>pair&lt;double, double&gt;</code> y definir todas sus funciones aparte. Esta forma de trabajar nos da una estructura c\u00f3moda para llegar y usar, adem\u00e1s de expandible.</p> <p>Pueden agregarle m\u00e1s funcionalidades \u00e9chando un vistazo a los siguientes c\u00f3digos:</p> <ul> <li>Implementaci\u00f3n de Benja</li> <li>Implementaci\u00f3n de Pablo</li> </ul>"},{"location":"notes/geometry/base_implementation/#material-consultado","title":"Material consultado","text":"<ul> <li>Handbook of geometry for competitive programmers.</li> </ul>"},{"location":"notes/geometry/dot_and_cross_product/","title":"Producto punto y producto cruz","text":"<p>Lo que llamamos producto punto y producto cruz son formas de multiplicar vectores. La primera nos da como resultado un n\u00famero mientras que la segunda nos da como resultado otro vector.</p> <p>M\u00e1s que conocer sus f\u00f3rmulas de computo, lo valioso de estas yace en su significado geom\u00e9trico.</p>"},{"location":"notes/geometry/dot_and_cross_product/#producto-punto","title":"Producto punto","text":"<p>El producto punto entre el vector \\(v\\) y el vector \\(w\\) es el largo de la proyecci\u00f3n del vector \\(v\\) sobre el vector \\(w\\) multiplicado por el largo del vector \\(w\\).</p> <p>Lo importante ac\u00e1 est\u00e1 en que nos da informaci\u00f3n sobre la proyecci\u00f3n de un vector sobre el otro. Si el producto es; positivo significa que forman un \u00e1ngulo agudo, si es cero entonces son perpendiculares y por \u00faltimo si es negativo quiere decir que forman siempre un \u00e1ngulo obtuso.</p> <p></p>"},{"location":"notes/geometry/dot_and_cross_product/#formula","title":"F\u00f3rmula","text":"<p>Sea \\(v\\) y \\(w\\) vectores en \\(\\mathbb{R}^2\\) entonces el producto punto entre ellos es:</p> \\[ (x_1, y_1) \\cdot (x_2, y_2) = x_1x_2 + y_1y_2 \\]"},{"location":"notes/geometry/dot_and_cross_product/#implementacion","title":"Implementaci\u00f3n","text":"<p>Usando la vista en base implementation.</p> <p> </p> <pre><code>T dot(pt v, pt w) { return v.x*w.x + v.y*w.y; } // (1)!\n</code></pre> <ol> <li> Definir esto afuera de la struct <code>pt</code>.</li> </ol> <p>Adem\u00e1s tambi\u00e9n podemos saber si dos vectores son perpendiculares o no:</p> <p> </p> <pre><code>bool is_perp(pt v, pt w) { return dot(v, w) == 0; } // (1)!\n</code></pre> <ol> <li> Definir esto afuera de la struct <code>pt</code>.</li> </ol>"},{"location":"notes/geometry/dot_and_cross_product/#producto-cruz","title":"Producto cruz","text":"<p>El producto cruz entre el vector \\(v\\) y el vector \\(w\\) es el vector perpendicular a ambos cuyo modulo es igual al \u00e1rea del paralelogramo que generan \\(v\\) y \\(w\\).</p> <p>Al igual que en el producto anterior, lo importante no est\u00e1 en la f\u00f3rmula si no que en el signo de su resultado. Si su producto es igual a cero entonces \\(v\\) y \\(w\\) son colineales. Por otro lado, si es positivo entonces \\(v\\) a \\(w\\) est\u00e1n en sentido antihorario, si es negativo est\u00e1n en sentido horario.</p> <p></p>"},{"location":"notes/geometry/dot_and_cross_product/#formula_1","title":"F\u00f3rmula","text":"<p>Sea \\(v\\) y \\(w\\) vectores en \\(\\mathbb{R}^2\\) entonces el producto cruz entre ellos es:</p> \\[ (x_1, y_1) \\times (x_2, y_2) = x_1y_2 - y_1x_2 \\]"},{"location":"notes/geometry/dot_and_cross_product/#implementacion_1","title":"Implementaci\u00f3n","text":"<p>Usando la vista en base implementation.</p> <p> </p> <pre><code>T cross(pt v, pt w) { return v.x*w.y - v.y*w.x; } // (1)!\n</code></pre> <ol> <li> Definir esto afuera de la struct <code>pt</code>.</li> </ol> <p>Adem\u00e1s tambi\u00e9n podemos saber si dos vectores son colineales o no:</p> <p> </p> <pre><code>bool is_colinear(pt v, pt w) { return cross(v, w) == 0; } // (1)!\n</code></pre> <ol> <li> Definir esto afuera de la struct <code>pt</code>.</li> </ol>"},{"location":"notes/geometry/dot_and_cross_product/#material-consultado","title":"Material consultado","text":"<ul> <li>Handbook of geometry for competitive programmers. De aqu\u00ed se sac\u00f3 las im\u00e1genes.</li> </ul>"},{"location":"notes/math/modular_arithmetic/","title":"Aritm\u00e9tica Modular","text":""},{"location":"notes/math/modular_arithmetic/#motivacion","title":"Motivaci\u00f3n","text":"<p>Muchas veces en programaci\u00f3n competitiva nos encontramos con problemas que involucran n\u00fameros muy grandes. Para poder entregar soluciones que no sobrepasen el l\u00edmite del tipo de dato <code>int</code> o <code>long long</code> se usa aritm\u00e9tica modular. El cual acorta los n\u00fameros a un rango espec\u00edfico y mantiene un buen funcionamiento de las operaciones.</p> <p>Otro uso de aritm\u00e9tica modular es ver la divisibilidad de un n\u00famero entre otro, o si un n\u00famero es primo o no. Adem\u00e1s de su uso directo en problemas de t\u00f3pico matem\u00e1tico, puede ser de ayuda cuando haya una noci\u00f3n ciclo involucrado en el problema.</p> <p></p> <p>Imagina que tienes un reloj de 12 horas y quieres saber qu\u00e9 hora es en 5 horas m\u00e1s. Si no usas aritm\u00e9tica modular, tendr\u00edas que hacer la cuenta de \\(x + 5\\). Pero tendr\u00edas que hacer una condici\u00f3n para ver si la hora es mayor a 12 y restarle 12. Con aritm\u00e9tica modular, la hora correcta es \\(x + 5 \\mod 12\\).</p> <p>La primera soluci\u00f3n ser\u00eda hacer algo as\u00ed:</p> <pre><code>int x = 7;\nint ans = x + 5;\nif (ans &gt; 12) ans -= 12;\ncout &lt;&lt; ans &lt;&lt; '\\n';\n</code></pre> <p>En cambio, con aritm\u00e9tica modular, la soluci\u00f3n ser\u00eda:</p> <pre><code>int x = 7;\nint y = (x + 5) % 12;\ncout &lt;&lt; y; // 12\n</code></pre> <p>Los lengajes de programaci\u00f3n tienen implementaciones de aritm\u00e9tica modular con el operador <code>%</code>.</p> <p>Despu\u00e9s de esta breve introducci\u00f3n, formalicemos (no en mayor medida) la aritm\u00e9tica modular.</p>"},{"location":"notes/math/modular_arithmetic/#definicion","title":"Definici\u00f3n","text":"<p>Diremos que un n\u00famero \\(a\\) es congruente a \\(b\\) m\u00f3dulo \\(n\\) si \\(a \\equiv b \\pmod{n}\\). Esto significa que \\(a\\) y \\(b\\) son iguales cuando se mira el resto que dejan al dividirlos entre \\(n\\). Por ejemplo, \\(5 \\equiv 2 \\pmod{3}\\), ya que \\(5 = 2 \\cdot 3 + 2\\) y \\(2 = 3 \\cdot 0 + 2\\).</p> <p>En <code>C++</code>, podemos usar el operador <code>%</code> para calcular el resto de la divisi\u00f3n de dos n\u00fameros. Por ejemplo, \\(5 \\mod 3 = 2\\) se puede calcular como <code>5 % 3</code>.</p>"},{"location":"notes/math/modular_arithmetic/#propiedades","title":"Propiedades","text":"<p>Procederemos a enunciar algunas propiedades importantes al momento de operar en aritm\u00e9tica modular.</p>"},{"location":"notes/math/modular_arithmetic/#propiedad-de-la-suma-de-congruencia","title":"Propiedad de la suma de congruencia","text":"<p>Si \\(a \\equiv b \\pmod{n}\\) y \\(c \\equiv d \\pmod{n}\\), entonces \\(a + c \\equiv b + d \\pmod{n}\\).</p> <p>Esto nos es \u00fatil para separar sumas en m\u00f3dulo \\(n\\). Por ejemplo, si queremos calcular \\(2 + 3 + 4 \\mod 5\\), podemos calcular \\(2 + 3 \\mod 5\\) y luego sumarle \\(4 \\mod 5\\).</p>"},{"location":"notes/math/modular_arithmetic/#propiedad-de-la-multiplicacion-de-congruencia","title":"Propiedad de la multiplicaci\u00f3n de congruencia","text":"<p>Si \\(a \\equiv b \\pmod{n}\\) y \\(c \\equiv d \\pmod{n}\\), entonces \\(ac \\equiv bd \\pmod{n}\\).</p> <p>Esto nos es \u00fatil para separar multiplicaciones en m\u00f3dulo \\(n\\). Por ejemplo, si queremos calcular \\(2 \\cdot 3 \\cdot 4 \\mod 5\\), podemos calcular \\(2 \\cdot 3 \\mod 5\\) y luego multiplicarle \\(4 \\mod 5\\). Tambi\u00e9n podemos usar esta propiedad para calcular potencias en m\u00f3dulo \\(n\\).</p>"},{"location":"notes/math/modular_arithmetic/#propiedad-de-la-inversa-de-suma-congruencia","title":"Propiedad de la inversa de suma congruencia","text":"<p>Si \\(a \\equiv b \\pmod{n}\\), entonces \\(a - b \\equiv 0 \\pmod{n}\\).</p> <p>Esto nos da la noci\u00f3n de elemento inverso en aritm\u00e9tica modular. Que es \u00fatil al momento de hacer ecuaciones lineales en m\u00f3dulo \\(n\\).</p>"},{"location":"notes/math/modular_arithmetic/#propiedad-de-la-inversa-de-multiplicacion-congruencia","title":"Propiedad de la inversa de multiplicaci\u00f3n congruencia","text":"<p>Si \\(a \\equiv b \\pmod{n}\\) y \\(b \\neq 0\\), entonces \\(a \\cdot b^{-1} \\equiv 1 \\pmod{n}\\). Donde \\(b^{-1}\\) es el inverso de \\(b\\) en el grupo de multiplicaci\u00f3n m\u00f3dulo \\(n\\). O sea, el n\u00famero \\(b^{-1}\\) tal que \\(b \\cdot b^{-1} \\equiv 1 \\pmod{n}\\).</p>"},{"location":"notes/strings/kmp/","title":"Algoritmo de Knuth-Morris-Pratt (KMP)","text":""},{"location":"notes/strings/kmp/#introduccion","title":"Introducci\u00f3n","text":"<p>El algoritmo de KMP es un algoritmo que sirve para encontrar todas las ocurrencias de un patr\u00f3n en un string. KMP es una mejora del algoritmo de fuerza bruta. El algoritmo de fuerza bruta revisa cada posici\u00f3n del string y va comparando el patr\u00f3n con el substring del string que empieza en esa posici\u00f3n. El algoritmo de KMP es m\u00e1s eficiente porque cada vez que hay una comparaci\u00f3n fallida, se salta a la siguiente posici\u00f3n del string donde es posible que el patr\u00f3n aparezca. Se aprovecha de las comparaciones parciales. Cosa que no hace el algoritmo de fuerza bruta.</p>"},{"location":"notes/strings/kmp/#observacion-base","title":"Observaci\u00f3n base","text":"<p>KMP se basa en la siguiente observaci\u00f3n. Si tenemos un patr\u00f3n el cual tiene una comparaci\u00f3n parcial correcta de un prefijo suyo. Si este \u00faltimo posee un prefijo (\\(p\\)) y un sufijo (\\(s\\)) que son iguales (\\(p = s\\)). Entonces si se falla en el siguiente car\u00e1cter, podemos saltar a cuando inicia el sufijo y asumir que el prefijo ya fue comparado correctamente. Esto se puede ver en la siguiente ejemplo:</p> <p>Patr\u00f3n a buscar <code>ABABAC</code>, string <code>ABABABAC</code>.</p> <p>Se hace el siguiente proceso:</p> <ol> <li> <p>Se compara hasta <code>ABABA</code>, la cual es una comparaci\u00f3n parcial correcta.</p> \\[     \\colorbox{yellowgreen}{ABABA} BAC \\] </li> <li> <p>Falla en la comparaci\u00f3n del car\u00e1cter <code>C</code> con el car\u00e1cter <code>B</code>.</p> \\[     \\colorbox{yellowgreen}{ABABA} \\colorbox{red}{B} AC \\] </li> <li> <p>Como el prefijo <code>ABABA</code> tiene un sufijo <code>ABA</code> y un prefijo <code>ABA</code> que son iguales, podemos saltar a la posici\u00f3n donde inicia el sufijo y asumir que el prefijo ya fue comparado correctamente.</p> \\[     AB\\colorbox{yellowgreen}{ABA}BAC \\] </li> <li> <p>Continuamos comparando hasta que se encuentra una comparaci\u00f3n total correcta.</p> \\[     AB\\colorbox{yellowgreen}{ABABAC} \\] </li> </ol> <p>Note</p> <p><code>ABABA</code> tambi\u00e9n ten\u00eda el prefijo/sufijo <code>A</code> pero si hubi\u00e9ramos saltado a esa posici\u00f3n no habr\u00edamos encontrado el patr\u00f3n en el string. De todos modos no siempre va a convenir utilizar el prefijo/sufijo m\u00e1s largo.</p>"},{"location":"notes/strings/kmp/#implementacion","title":"Implementaci\u00f3n","text":"<p>La implementaci\u00f3n de KMP es muy similar a la de fuerza bruta. La diferencia es que vamos a dar saltos en el string cuando hay una comparaci\u00f3n parcial fallida. Pero primero debemos calcular los saltos que vamos a dar.</p>"},{"location":"notes/strings/kmp/#funcion-de-fallo","title":"Funci\u00f3n de fallo","text":"<p>Vamos a ocupar la observaci\u00f3n y calcularemos el largo del prefijo/sufijo m\u00e1s largo para cada prefijo del patr\u00f3n. Si no tiene, entonces su largo ser\u00e1 de \\(0\\).</p> <p>Sigamos con el mismo ejemplo donde el patr\u00f3n es <code>ABABAC</code>. Su arreglo de prefijos/sufijos m\u00e1s largos \\(f\\) ser\u00e1:</p> <p> Prefijo Prefijo m\u00e1s largo Largo prefijo m\u00e1s largo (\\(f(i)\\)) \"\" \"\" 0 <code>A</code> \"\" 0 <code>AB</code> \"\" 0 <code>ABA</code> <code>A</code> 1 <code>ABAB</code> <code>AB</code> 2 <code>ABABA</code> <code>ABA</code> 3 <code>ABABAC</code> \"\" 0 <p></p> <p>Donde \"\" es el string vac\u00edo.</p> <p>Llamaremos \\(f(i)\\) al largo del prefijo/sufijo m\u00e1s largo del prefijo del patr\u00f3n de largo \\(i\\).</p> <p>Notemos que \\(f(f(i))\\) es la segunda mejor coincidencia de prefijo/sufijo m\u00e1s largo. Por ejemplo, si \\(f(5) = 3\\), entonces \\(f(3) = 1\\). Que coincide con que <code>ABABA</code> tiene tanto a <code>ABA</code> como a <code>A</code> como prefijo/sufijo's. Esto se puede iterar, y obtener el tercero mejor, cuarto mejor y as\u00ed, hasta llegar a \\(f(f(\\ldots)) = 0\\).</p> <p>Esta observaci\u00f3n nos sirve para calcular \\(f(i)\\) sabiendo todos los \\(f(j)\\) con \\(j &lt; i\\). \\(f(i)\\) va a ser igual al largo del prefijo/sufijo m\u00e1s largo del prefijo de largo \\(i - 1\\) que se pueda extender con el car\u00e1cter \\(i\\)-\u00e9simo, o sea que siga siendo prefijo/sufijo del prefijo \\(i\\). Por lo que hay que comprobar con todos los prefijo/sufijo's del prefijo de largo \\(i - 1\\). Ac\u00e1 ocupamos la observaci\u00f3n iterando \\(f(i-1)\\) sobre si misma.</p>"},{"location":"notes/strings/kmp/#codigo","title":"C\u00f3digo","text":"<p>A esto se le llama funci\u00f3n de fallo y su implementaci\u00f3n en C++ es la siguiente:</p> <p> </p> <pre><code>vector&lt;int&gt; failure_function(string pattern) {\nint n = pattern.size();\nvector&lt;int&gt; f(n + 1);\nf[0] = f[1] = 0;    // (1)!\nfor (int i = 2; i &lt;= n; i++) {\nint j = f[i - 1];    // (2)!\nwhile (j &gt; 0 &amp;&amp; pattern[j] != pattern[i - 1]){    // (3)!\nj = f[j];\n}\nif (pattern[j] == pattern[i - 1]){    // (4)!\nj++;\n}\nf[i] = j;    // (5)!\n}\nreturn f;\n}\n</code></pre> <ol> <li> Inicializamos los casos base.</li> <li> Inicializamos j con el prefijo/sufijo m\u00e1s largo del prefijo de largo i - 1.</li> <li> Iteramos siempre y cuando no podamos extender el prefijo/sufijo del prefijo de largo i - 1 con el car\u00e1cter j-\u00e9simo.</li> <li> Si podemos extender el prefijo/sufijo del prefijo de largo i - 1 con el car\u00e1cter j-\u00e9simo, entonces lo extendemos.</li> <li> Guardamos el prefijo/sufijo m\u00e1s largo del prefijo de largo i.</li> </ol>"},{"location":"notes/strings/kmp/#implementacion-kmp","title":"Implementaci\u00f3n KMP","text":"<p>Ahora que tenemos la funci\u00f3n de fallo podemos implementar el algoritmo KMP.</p> <p>Como ya se mencion\u00f3 en un inicio, la idea va a ser que cada que una comparaci\u00f3n parcial falle, vamos a saltar a la posici\u00f3n donde inicia el prefijo/sufijo m\u00e1s largo del prefijo que ya fue comparado. Y continuamos con el siguiente car\u00e1cter. Si este siguiente car\u00e1cter no coincide, intentamos con el segundo mejor prefijo/sufijo. Y as\u00ed sucesivamente hasta llegar a que no hayan m\u00e1s prefijos/sufijos o que alguno calce, y continuamos con la comparaci\u00f3n parcial normal.</p>"},{"location":"notes/strings/kmp/#codigo_1","title":"C\u00f3digo","text":"<p>El c\u00f3digo de KMP en C++ es el siguiente:</p> <p> </p> <pre><code>vector&lt;int&gt; kmp(string text, string pattern) {\nvector&lt;int&gt; f = failure_function(pattern);\nvector&lt;int&gt; matches;\nint n = text.size();\nint m = pattern.size();\nint i = 0, j = 0;    // (1)!\nwhile (i &lt; n) {\nif (text[i] == pattern[j]) {    // (2)!\ni++;\nj++;\nif (j == m) {   // (3)!\nmatches.push_back(i - m);\nj = f[j];\n}\n} else if (j &gt; 0) {    // (4)!\nj = f[j];\n} else {    // (5)!\ni++;\n}\n}\nreturn matches;\n}\n</code></pre> <ol> <li> i es el \u00edndice del texto y j es el \u00edndice del patr\u00f3n.</li> <li> Si el car\u00e1cter i-\u00e9simo del texto coincide con el car\u00e1cter j-\u00e9simo del patr\u00f3n, entonces avanzamos ambos \u00edndices. </li> <li> Si j llega a ser igual al largo del patr\u00f3n, entonces encontramos una coincidencia y guardamos la posici\u00f3n donde inicia el patr\u00f3n en el texto. Luego, asignamos j al prefijo/sufijo m\u00e1s largo del prefijo de largo j.</li> <li> Si j es mayor a 0, significa que estamos buscar el prefijo/sufijo m\u00e1s largo del prefijo de largo j que coincida con la expansi\u00f3n del car\u00e1cter i-\u00e9simo del texto. Por lo que vamos por el siguiente candidato, f(j). </li> <li> Si no, entonces avanzamos i. Este es el caso de la b\u00fasqueda normal.</li> </ol>"},{"location":"notes/strings/kmp/#material-consultado","title":"Material consultado","text":"<ul> <li>Introduction to String Searching Algorithms \u2014 topcoder</li> </ul>"},{"location":"notes/strings/rolling_hashing/","title":"Rolling Hashing","text":""},{"location":"notes/strings/rolling_hashing/#introduccion","title":"Introducci\u00f3n","text":"<p>Supongamos que quieres saber si el d\u00edgito \\(0\\) esta o no dentro de un numero muy grande. Este es un cl\u00e1sico algoritmo de b\u00fasqueda secuencial donde ves d\u00edgito por d\u00edgito si es igual o no a \\(0\\). Si el largo del numero es de \\(n\\) entonces la complejidad es \\(\\mathcal{O}(n)\\).</p> <p>Modifiquemos un poco el problema y en vez de saber si un d\u00edgito est\u00e1 en el numero preguntemos si un string est\u00e1 dentro de otro. Por ejemplo, verificar si <code>abc</code> est\u00e1 en <code>abracadabra</code>. Al ocupar el mismo algoritmo de b\u00fasqueda secuencial la complejidad no ser\u00e1 de \\(\\mathcal{O}(n)\\) ya que la comparaci\u00f3n de strings se hace car\u00e1cter por car\u00e1cter. De hecho su complejidad es de \\(\\mathcal{O}(n \\cdot m)\\) donde \\(m\\) es el largo del string que estamos buscando.</p> <p>Ac\u00e1 es donde entra el algoritmo de Rolling Hashing. Este algoritmo nos va a permitir comparar dos strings en \\(\\mathcal{O}(1)\\). La intuici\u00f3n por detr\u00e1s es que vamos a transformar cada substring que queremos comparar en un d\u00edgito para que asi hacer uns b\u00fasqueda secuencial con n\u00fameros. Los cuales son comparados en \\(\\mathcal{O}(1)\\).</p> <p>Info</p> <p>Un hash es una funci\u00f3n que sirve para almacenar y recuperar datos de una manera eficiente.</p>"},{"location":"notes/strings/rolling_hashing/#hashing","title":"Hashing","text":"<p>Para calcular el hash de una cadena ocupamos polynomial hashing. La idea es que cada car\u00e1cter de la cadena se encripta en un n\u00famero. Y luego anidamos para alguna base.</p> <p>Intuici\u00f3n</p> <p>Pasar de <code>abc</code> \\(\\rightarrow\\) <code>123</code> y <code>dcbe</code> \\(\\rightarrow\\) <code>4321</code>.</p> <p>El problema es que si la cadena es muy larga, el n\u00famero podr\u00eda ser muy grande y no caber en un <code>int</code> (overflow). Para solucionar esto ocuparemos aritm\u00e9tica modular.</p> <p>Sea \\(S\\) el string que queremos encriptar, y \\(A\\) y \\(B\\) dos primos. Entonces, el hash de \\(S\\) es:</p> \\[ \\sum_{i=0}^{n-1} S[i] \\cdot A^i \\mod B \\] <p>Cada car\u00e1cter se multiplica por una potencia de \\(A\\) para minimizar la probabilidad de colisiones. El m\u00f3dulo \\(B\\) es para evitar que el n\u00famero sea muy grande y tengamos problemas de overflow. El valor de cada car\u00e1cter (\\(S[i]\\)) se puede obtener de la tabla ASCII o de alguna otra tabla que se nos ocurra.</p>"},{"location":"notes/strings/rolling_hashing/#ejemplo","title":"Ejemplo","text":"<p>Supongamos que queremos calcular el hash de la cadena <code>\"PABLO\"</code>. El valor ASCII de cada car\u00e1cter es:</p> <p> P A B L O 80 65 66 76 79 <p></p> <p>Ocupando los primos \\(A=31\\) y \\(B=10^9 + 7\\):</p> \\[ \\begin{aligned} 80 \\cdot 31^0 + 65 \\cdot 31^1 + 66 \\cdot 31^2 + 76 \\cdot 31^3 + 79 \\cdot 31^4 \\mod (10^9 + 7) = 75287796 \\end{aligned} \\] <p>En c\u00f3digo ser\u00eda:</p> <p> </p> <pre><code>int pol_hash(string s) {\nint A = 31, B = 1e9 + 7;\nint n = s.size(), h = 0;\nfor (int i = n - 1; i &gt;= 0; i--) {\nh = (h * A + s[i]) % B;\n}\nreturn h;\n}\n</code></pre>"},{"location":"notes/strings/rolling_hashing/#preprocesamiento","title":"Preprocesamiento","text":"<p>Recordemos que queremos ocupar rolling hashing para resolver problemas de b\u00fasqueda de un string en otro m\u00e1s grande. En cuyo caso no nos conviene estar calculando el hash de cada substring a comparar en cada consulta. En vez de eso, ocuparemos un arreglo de hashes, donde cada posici\u00f3n \\(i\\) del arreglo contiene el hash de la cadena desde la posici\u00f3n \\(i\\) hasta el final.</p> <p>Supongamos que \\(h\\) es dicho arreglo y que \\(i &lt; j\\). Entonces:</p> \\[ \\begin{aligned} h[i] = \\sum_{k=i}^{n-1} S[k] \\cdot A^{k-i} \\mod B \\\\ h[j] = \\sum_{k=j}^{n-1} S[k] \\cdot A^{k-j} \\mod B \\end{aligned} \\] <p>Si intentamos restar \\(h[i]\\) a \\(h[j]\\) se obtiene:</p> \\[ \\begin{aligned} h[i] - h[j] &amp;= \\sum_{k=i}^{n-1} S[k] \\cdot A^{k-i} - \\sum_{k=j}^{n-1} S[k] \\cdot A^{k-j} \\mod B \\\\ &amp;= \\left ( \\sum_{k=i}^{j-1} S[k] \\cdot A^{k-i} + \\sum_{k=j}^{n-1} S[k] \\cdot A^{k-i} \\right ) - \\sum_{k=j}^{n-1} S[k] \\cdot A^{k-j} \\mod B \\end{aligned} \\] <p>Para cancelar las dos sumatorias de la derecha hace falta multiplicar \\(h[j]\\) por \\(A^{j-i}\\). Ahora si tendremos que:</p> \\[ \\begin{aligned} h[i] - h[j] \\cdot A^{j-i} &amp;= \\sum_{k=i}^{j-1} S[k] \\cdot A^{k-i} \\mod B \\end{aligned} \\] <p>Por lo que \\(h[i] - h[j] \\cdot A^{j-i}\\) es el hash de \\(S[i \\dots j]\\) (sin contar al car\u00e1cter \\(j\\)-\u00e9simo).</p> <p>Ahora, veamos c\u00f3mo calcular \\(h[i]\\) para cada \\(i\\). Para ello podemos aprovecharnos d ela siguiente recursi\u00f3n:</p> \\[ \\begin{aligned} h[0] &amp;= S[0] \\\\ h[i] &amp;= S[i] + S[i - 1] \\cdot A \\\\ \\end{aligned} \\] <p>Adem\u00e1s de esto, ocuparemos un arreglo \\(p\\) que contiene las potencias de \\(A\\):</p> \\[ \\begin{aligned} p[0] &amp;= 1 \\\\ p[i] &amp;= p[i - 1] \\cdot A \\mod B \\\\ \\end{aligned} \\] <p>As\u00ed, el hash de un substring \\(S[i \\dots j]\\) es:</p> \\[ \\begin{aligned} h[i] - h[j + 1] \\cdot p[j - i + 1] \\mod B \\\\ \\end{aligned} \\] <p>y en el caso de que \\(i = 0\\) se reduce a \\(h[j]\\).</p>"},{"location":"notes/strings/rolling_hashing/#implementacion","title":"Implementaci\u00f3n","text":""},{"location":"notes/strings/rolling_hashing/#codigo","title":"C\u00f3digo","text":"<p>Pueden encontrar la implementaci\u00f3n de rolling hashing en el siguiente link. Esta implementaci\u00f3n es con dos \\(B\\), pero es b\u00e1sicamente la misma que se muestra a continuaci\u00f3n.</p> <p>La funci\u00f3n <code>preprocessor</code> que calcula los hashes de cada posici\u00f3n del string \\(S\\). Y la funci\u00f3n <code>get_hash</code> que calcula el hash de un substring \\(S[i \\dots j]\\):</p> <p> </p> <pre><code>const int MAXN = 1e5 + 5;\nconst int A = 31;\nconst int B = 1e9 + 7;\nint n;\nstring s;\nint h[MAXN], p[MAXN];\nvoid preprocessor() {\np[0] = 1;\nfor (int i = 1; i &lt;= n; i++) {\np[i] = (p[i - 1] * A) % B;\n}\nh[0] = s[0];\nfor (int i = n - 1; i &gt;= 0; i--) {\nh[i] = (h[i + 1] * A + s[i]) % B;\n}\n}\nint get_hash(int i, int j) {\nreturn (h[i] - h[j] * p[j - i] + B * B) % B;\n}\n</code></pre>"},{"location":"notes/strings/rolling_hashing/#uso","title":"Uso","text":"<p>Supongamos que queremos encontrar el primer substring de \\(S\\) que es igual a <code>\"PABLO\"</code>. Usando la funci\u00f3n <code>get_hash</code> podemos calcular el hash de <code>\"PABLO\"</code> y luego comparar con los hashes de cada posici\u00f3n de \\(S\\):</p> <p> </p> <pre><code>int main() {\ncin &gt;&gt; s;\nn = s.size();\npreprocessor();\nstring r = \"PABLO\";\nint m = r.size();\nint l = pol_hash(r);\nfor (int i = 0; i + m - 1 &lt; n; i++) {\nif (get_hash(i, i + m) == l) {\ncout &lt;&lt; i &lt;&lt; '\\n';\nbreak;\n}\n}\nreturn 0;\n}\n</code></pre>"},{"location":"notes/strings/rolling_hashing/#recomendaciones","title":"Recomendaciones","text":"<ul> <li>Los jueces pueden tener casos de prueba que haga que se caigan las soluciones con constantes conocidas (a.k.a. \\(10^9 + 7\\)). En ese caso, se recomienda ocupar n\u00fameros primos aleatorios, pero que est\u00e9n en el rango de \\(10^9\\).</li> </ul>"},{"location":"notes/strings/rolling_hashing/#material-consultado","title":"Material consultado","text":"<ul> <li>Competitive Programmer\u2019s Handbook \u2014 String Hashing</li> <li>ProgompCL \u2014 Rolling Hashing</li> </ul>"},{"location":"notes/strings/trie_string/","title":"Trie String","text":""},{"location":"notes/strings/trie_string/#introduccion","title":"Introducci\u00f3n","text":"<p>Trie string es una forma de guardar un conjunto de strings. La idea es almacenar los strings en un \u00e1rbol, donde cada nodo es un car\u00e1cter. De forma que si seguimos cada camino desde la ra\u00edz hasta alguna de sus hoja podamos reconstruir un string del conjunto original.</p>"},{"location":"notes/strings/trie_string/#creacion-del-arbol-con-un-ejemplo","title":"Creaci\u00f3n del \u00e1rbol con un ejemplo","text":"<p>La mejor manera de entender este algoritmo es con un ejemplo. As\u00ed que veamos c\u00f3mo hacer con los strings <code>tree</code>, <code>trie</code>, <code>algo</code>, <code>assoc</code>, <code>all</code> y <code>also</code>.</p> <p>Empezamos con el \u00e1rbol vac\u00edo solo con la ra\u00edz.</p> <p> <pre><code>graph TD\n    A[root]\n\nstyle A fill:#6b9cd5,stroke:#333</code></pre> <p></p> <p>Luego anexamos el primer string <code>tree</code> car\u00e1cter por car\u00e1cter.</p> <p> <pre><code>graph TD\n    A[root] --&gt; B((t))\n    B --&gt; C((r))\n    C --&gt; D((e))\n    D --&gt; E((e))\n    E:::leaf\n\nstyle A fill:#6b9cd5,stroke:#333\nclassDef leaf fill:#f96;</code></pre> <p></p> <p>Note</p> <p>Pintamos de naranja los nodos finales (hojas) para indicar que el string termina ah\u00ed (asi podemos distinguir strings que son prefijos de otros). Esto se ver\u00e1 en la implementaci\u00f3n.</p> <p>Veamos el siguiente string, <code>trie</code>.</p> <ol> <li>Revisamos si el nodo <code>root</code> tiene un hijo cuyo car\u00e1cter es igual a <code>t</code>.</li> <li>\u00a1Existe! se revisa si el nodo <code>t</code> tiene un hijo cuyo car\u00e1cter es igual a <code>r</code>.</li> <li>\u00a1Existe! se revisa si el nodo <code>r</code> tiene un hijo cuyo car\u00e1cter es igual a <code>i</code>.</li> <li>No existe :( a\u00f1adimos el string restante <code>ie</code> como un camino debajo del nodo <code>r</code>.</li> </ol> <p> <pre><code>graph TD\n    A[root] --&gt; B((t))\n    B --&gt; C((r))\n    C --&gt; D((e))\n    D --&gt; E((e))\n    E:::leaf\n    C --&gt; G((i))\n    G --&gt; H((e))\n    H:::leaf\n\nstyle A fill:#6b9cd5,stroke:#333\nclassDef leaf fill:#f96;</code></pre> <p></p> <p>Procedemos de forma an\u00e1loga con los dem\u00e1s strings. El \u00e1rbol quedar\u00eda de la siguiente forma:</p> <p><code>tree</code>, <code>trie</code>, <code>algo</code>, <code>assoc</code>, <code>all</code> y <code>also</code>.</p> <p> <pre><code>graph TD\n    A[root] --&gt; B((t))\n    B --&gt; C((r))\n    C --&gt; D((e))\n    D --&gt; E((e))\n    E:::leaf\n    C --&gt; G((i))\n    G --&gt; H((e))\n    H:::leaf\n    A[root] --&gt; J((a))\n    J --&gt; K((l))\n    K --&gt; L((g))\n    L --&gt; M((o))\n    M:::leaf\n    J --&gt; O((s))\n    O --&gt; P((s))\n    P --&gt; Q((o))\n    Q --&gt; R((c))\n    R:::leaf\n    J --&gt; T((l))\n    T --&gt; U((l))\n    U:::leaf\n    K --&gt; W((s))\n    W --&gt; X((o))\n    X:::leaf\n\nstyle A fill:#6b9cd5,stroke:#333\nclassDef leaf fill:#f96;</code></pre> <p></p> <p>Note</p> <p>Comprobar si un string est\u00e1 o no en el \u00e1rbol es b\u00e1sicamente el mismo proceso que para a\u00f1adirlo. Salvo que cuando no coincida un car\u00e1cter en el camino, se termina la b\u00fasqueda.</p>"},{"location":"notes/strings/trie_string/#implementacion","title":"Implementaci\u00f3n","text":"<p>Pueden encontrar la implementaci\u00f3n de trie string en el siguiente link. Con un ejemplo de uso.</p> <p>Para implementar este algoritmo necesitamos una estructura de datos que nos permita guardar el \u00e1rbol. Ocuparemos una clase <code>Trie</code> que tendr\u00e1 un nodo ra\u00edz, un m\u00e9todo <code>insert</code> para a\u00f1adir strings al \u00e1rbol y un m\u00e9todo <code>find</code> para buscar strings en el \u00e1rbol.</p> <p> </p> <pre><code>class Trie {\nstruct Node {   // (1)!\nchar c;\nbool leaf;\nvector&lt;Node*&gt; children;\nNode(char c) : c(c), leaf(false) {}\n};\nNode* root;\npublic:\nTrie() : root(new Node('\\0')) {}    // (2)!\nvoid insert(string s) {    // (3)!\nNode* cur = root;\nfor (char c : s) {\nbool found = false;\nfor (Node* child : cur-&gt;children) {\nif (child-&gt;c == c) {\ncur = child;\nfound = true;\nbreak;\n}\n}\nif (!found) {\nNode* new_node = new Node(c);\ncur-&gt;children.push_back(new_node);\ncur = new_node;\n}\n}\ncur-&gt;leaf = true;\n}\nbool find(string s) {   // (4)!\nNode* cur = root;\nfor (char c : s) {\nbool found = false;\nfor (Node* child : cur-&gt;children) {\nif (child-&gt;c == c) {\ncur = child;\nfound = true;\nbreak;\n}\n}\nif (!found) return false;\n}\nreturn cur-&gt;leaf;\n}\n};\n</code></pre> <ol> <li>La struct <code>Node</code> es una estructura que guarda un car\u00e1cter, un booleano que indica si es una hoja y un vector de punteros a nodos hijos.</li> <li>El constructor de la clase <code>Trie</code> inicializa el nodo ra\u00edz con el car\u00e1cter nulo.</li> <li>El m\u00e9todo <code>insert</code> recibe un string y lo a\u00f1ade al \u00e1rbol. Se recorre el string car\u00e1cter por car\u00e1cter y se busca si el nodo actual tiene un hijo con el car\u00e1cter actual. Si no existe, se crea un nuevo nodo con el car\u00e1cter actual y se a\u00f1ade como hijo del nodo actual. Luego se actualiza el nodo actual al nodo reci\u00e9n creado. Al final se marca el \u00faltimo nodo como hoja.</li> <li>El m\u00e9todo <code>find</code> recibe un string y busca si est\u00e1 en el \u00e1rbol. Se recorre el string car\u00e1cter por car\u00e1cter y se busca si el nodo actual tiene un hijo con el car\u00e1cter actual. Si no existe, se retorna <code>false</code>. Cuando sale del ciclo, se retorna <code>true</code> siempre y cuando el \u00faltima car\u00e1cter era una hoja. </li> </ol>"},{"location":"notes/strings/trie_string/#material-consultado","title":"Material consultado","text":"<ul> <li>Tries, Patricia Tries \u2014 Programaci\u00f3n Competitiva CL</li> <li>Trie String \u2014 GeeksForGeeks</li> </ul>"},{"location":"resources/","title":"Recursos","text":""},{"location":"resources/#para-aprender-c-ojo-novats","title":"Para aprender C++ (&lt;&lt;&lt;&lt;&lt;&lt; OJO, NOVAT@S)","text":""},{"location":"resources/#recursos-para-temas-especificos","title":"Recursos para temas espec\u00edficos","text":"<ul> <li>Backtracking</li> <li>Binary &amp; Ternary Search</li> <li>Data Structures</li> <li>Dynamic Programming (DP)</li> <li>Greedy</li> <li>Divide and Conquer</li> <li>Graphs</li> <li>Strings</li> <li>Mathematics</li> <li>Geometry</li> <li>Square Root Decomposition</li> </ul>"},{"location":"resources/#recursos-generales","title":"Recursos generales","text":"<ul> <li>Canales de Youtube con muchas explicaciones:</li> <li>Gaurav Sen</li> <li>WillianFiset</li> <li>Abdul Bari</li> <li>Algorithms Live!</li> <li>Tushar Roy - Coding Made Simple</li> <li>Agust\u00edn Santiago Guti\u00e9rrez [elsantodel90]</li> <li>Programaci\u00f3n Competitiva CL</li> <li>Repositorios con muchos c\u00f3digos de ejemplo (implementaciones de algoritmos y estructuras de datos t\u00edpicos):</li> <li>Apuntes USACO &lt;&lt;&lt;&lt;&lt;&lt;&lt; BRUTAL, ESTOS APUNTES SON DEMASIADO BUENOS</li> <li>Apuntes Benjamin Rubio (ex seleccionado PUC)</li> <li>ICPC Team Notebook. Team \"UNC - Gracias Demetrio\" &lt;&lt;&lt;&lt;&lt;&lt;&lt; MUY BUENOS TAMBI\u00c9N</li> <li>Apuntes ICPC Universidad de Chile (C++)</li> <li>https://github.com/kth-competitive-programming/kactl</li> <li>Apuntes ICPC de Robinson Castro et al (C++)</li> <li>Apuntes ICPC de Ignacio Hermosilla (C++)</li> <li>C++ Cheat Sheet for ACM ICPC</li> <li>Stanford University ICPC Team Notebook</li> <li>Repo de Apuntes del team Caloventor en Dos (C++)</li> <li>Repo de Apuntes de Pablo Messina (C++)</li> <li>Otras p\u00e1ginas con links a muchos recursos y material de estudio:</li> <li>CP-ALGORITHMS &lt;&lt;&lt;&lt;&lt;&lt; EXCELENTE P\u00c1GINA, MEGA RECOMENDADA</li> <li>Codeforces: An awesome list for competitive programming!<ul> <li>All of the good tutorials found on codeforces</li> </ul> </li> <li>Standford CS 97SI: Introduction to Programming Contests</li> <li>GeeksForGeeks: HOW TO PREPARE FOR ACM ICPC</li> <li>GeeksForGeeks: Top 10 Algorithms and Data Structures for Competitive Programming</li> <li>Sitio web del Taller de la U. de Chile</li> <li>Techie Delight: Coding made easy</li> <li>Material Campamento 2015 progcomp.cl</li> <li>Material Campamento 2016 progcomp.cl</li> <li>Material Campamento 2017 progcomp.cl</li> <li>Material Campamento 2018 progcomp.cl</li> <li>Libros con harto material de programaci\u00f3n competitiva:</li> <li>Competitive Programmer's Handbook</li> <li>Competitive Programming 2</li> <li>Competitive Programming 3 (CP3)</li> </ul>"},{"location":"resources/#soluciones-de-regionales-latinoamericanas","title":"Soluciones de Regionales Latinoamericanas","text":"<ul> <li>Blogs con explicaciones:</li> <li>Blog CaloventorEnDos</li> <li>Chocoblog</li> <li>Codeforces - ACM ICPC 2011 Latin America Finals</li> <li>Codeforces - ACM ICPC 2012 Latin America Finals</li> <li>Codeforces - ACM ICPC 2014 Latin America Finals</li> <li>Codeforces - ACM ICPC 2015 Latin America Finals</li> <li>Codeforces - ACM ICPC 2016 Latin America Finals</li> <li>Codeforces - ACM ICPC 2017 Latin America Finals</li> <li>Codeforces - ACM ICPC 2018 Latin America Finals</li> <li>Codeforces - ACM ICPC 2019 Latin America Finals</li> <li>Codeforces - ACM ICPC 2020 Latin America Finals</li> <li>Explicaciones de problemas 2020: Discuss\u00e3o dos problemas da Final</li> <li>Google Sheet con soluciones de las \u00faltimas regionales (WIP)</li> </ul>"},{"location":"resources/#soluciones-inputs-y-outputs-oficiales-de-regionales","title":"Soluciones, Inputs y Outputs oficiales de Regionales","text":"<ul> <li>Latinoam\u00e9rica:</li> <li>http://maratona.ime.usp.br/</li> <li>Norteam\u00e9rica:</li> <li>http://acmgnyr.org</li> <li>http://cs.ecs.baylor.edu/~hamerly/icpc/</li> <li>http://www.acmicpc-pacnw.org/results.htm</li> <li>http://icpc-ecna.ysu.edu/PastResults/</li> </ul>"},{"location":"resources/backtracking/","title":"Backtracking","text":"<ul> <li>https://progcomp.cl/backtracking</li> <li>6 Introduction to Backtracking - Brute Force Approach: https://www.youtube.com/watch?v=DKCbsiDBN6c</li> <li>6.1 N Queens Problem using Backtracking: https://www.youtube.com/watch?v=xFv_Hl4B83A</li> <li>6.2 Sum Of Subsets Problem - Backtracking: https://www.youtube.com/watch?v=kyLxTdsT8ws</li> <li>6.3 Graph Coloring Problem - Backtracking: https://www.youtube.com/watch?v=052VkKhIaQ4</li> <li>Algor\u00edtmia - Tema 5. Backtracking. N-Reinas - Andr\u00e9s Mu\u00f1oz Ortega: https://www.youtube.com/watch?v=XQYGwKiqV3Y</li> </ul>"},{"location":"resources/data_structures/","title":"Estructuras de Datos","text":""},{"location":"resources/data_structures/#c-stl-data-structures-para-llegar-y-usar","title":"C++ STL Data Structures (para llegar y usar)","text":"<ul> <li>Utils:</li> <li>pairs &amp; tuples: video, doc pairs, doc tuples, geeksforgeeks, c\u00f3digo</li> <li> <p>iterators: video, docu, geeksforgeeks 1, geeksforgeeks 2, c\u00f3digo</p> </li> <li> <p>Sequence Containers:</p> </li> <li>youtube: Introduction of STL #2: Sequence Containers (el video cubre vector, deque, list, forward list, array)</li> <li>youtube: C++ STL Part - 7 : The Container Adapters - Stack, Queue &amp; Priority Queue (el video cubre stack, queue y priority_queue)</li> <li>arrays: documentaci\u00f3n, c\u00f3digo</li> <li>vector: documentaci\u00f3n, geeksforgeeks, c\u00f3digo</li> <li>deque: documentaci\u00f3n, geeksforgeeks, c\u00f3digo</li> <li>queue: documentaci\u00f3n, geeksforgeeks, c\u00f3digo</li> <li>stack: documentaci\u00f3n, geeksforgeeks, c\u00f3digo</li> <li>priority_queue (minheap / maxheap): documentaci\u00f3n, geeksforgeeks, c\u00f3digo</li> <li> <p>list (lista doblemente ligada): documentaci\u00f3n, geeksforgeeks, c\u00f3digo</p> </li> <li> <p>Associative Containers:</p> </li> <li>youtube: Introduction of STL #3: Associative Containers (el video cubre set, multiset, map, multimap)</li> <li>Set: documentaci\u00f3n, geeksforgeeks, c\u00f3digo</li> <li>Multiset: documentaci\u00f3n, geeksforgeeks, c\u00f3digo</li> <li>Map: documentaci\u00f3n, geeksforgeeks, c\u00f3digo</li> <li> <p>Multimap: documentaci\u00f3n, geeksforgeeks, c\u00f3digo</p> </li> <li> <p>Unordered Containers:</p> </li> <li>Introduction of STL #4: Unordered Containers (el video cubre unordered set/multiset/map/multimap)</li> <li>unordered_set: documentaci\u00f3n, geeksforgeeks, c\u00f3digo</li> <li>unordered_multiset: documentaci\u00f3n, geeksforgeeks, c\u00f3digo</li> <li>unordered_map: documentaci\u00f3n, geeksforgeeks, c\u00f3digo</li> <li> <p>unordered_multimap: documentaci\u00f3n, geeksforgeeks, c\u00f3digo</p> </li> <li> <p>Policy based data structures:</p> </li> <li>codeforces: C++ STL: Policy based data structures</li> <li>geeksforgeeks: Policy based data structures in g++</li> <li>orderered_set: geeksforgeeks, c\u00f3digo</li> </ul>"},{"location":"resources/data_structures/#repos-con-implementaciones-de-estructuras-de-datos","title":"Repos con implementaciones de estructuras de datos","text":"<ul> <li>Apuntes de Benja</li> <li>Apuntes de Pablo</li> </ul>"},{"location":"resources/data_structures/#sparse-table","title":"Sparse Table","text":"<ul> <li>(youtube)Sparse Table Algorithm Range Minimum Query</li> <li>(youtube)Sparse Table Tutorial / RMQ</li> <li>cp-algorithms: sparse table</li> <li>C\u00f3digo 1, C\u00f3digo 2</li> </ul>"},{"location":"resources/data_structures/#segment-tree","title":"Segment Tree","text":"<ul> <li>cp-algorithms: segment tree</li> <li>http://progcomp.cl/segmenttree</li> <li>(youtube) Segment Tree Range Minimum Query</li> <li>(youtube) Segment Tree [ICPCCL 2016]</li> <li>(codeforces) Efficient and easy segment trees (c\u00f3mo hacer segment trees iterativos)</li> <li>C\u00f3digo 1, C\u00f3digo 2</li> </ul>"},{"location":"resources/data_structures/#segment-tree-lazy","title":"Segment Tree Lazy","text":"<ul> <li>cp-algorithms: segment tree lazy</li> <li>youtube: Lazy Propagation Segment Tree</li> <li>youtube: Segment Tree - Range Queries with Lazy Updates</li> <li>C\u00f3digo 1, C\u00f3digo 2</li> </ul>"},{"location":"resources/data_structures/#fenwick-tree-aka-bit-o-binary-indexed-tree","title":"Fenwick Tree (a.k.a. BIT o Binary Indexed Tree)","text":"<ul> <li>(youtube) Tutorial: Binary Indexed Tree (Fenwick Tree)</li> <li>(youtube) Fenwick Tree explicado por Jorge P\u00e9rez</li> <li>https://youtu.be/0PzR0IoqkkU?t=1453 (por si quieren ver la explicaci\u00f3n de sweep line tambi\u00e9n que viene justo antes)</li> <li>(youtube) youtube: Fenwick Tree or Binary Indexed Tree</li> <li>cp-algorithms: fenwick tree</li> <li>HackerEarth - binary indexed tree made easy</li> <li>http://progcomp.cl/fenwicktree</li> <li>cs.stackexchange: BIT: What is the intuition behind a binary indexed tree and how was it thought about?</li> <li>Topcoder: binary indexed trees</li> <li>Fenwick Tree 2D:</li> <li>geeksforgeeks - Two Dimensional Binary Indexed Tree or Fenwick Tree</li> <li>youtube: explicaci\u00f3n de Jorge P\u00e9rez</li> <li>Topcoder: BIT 2D</li> <li>C\u00f3digos de ejemplo:</li> <li>Fenwick tree 1D: C\u00f3digo 1, C\u00f3digo 2</li> <li>Fenwick tree 2D: C\u00f3digo 1, C\u00f3digo 2</li> </ul>"},{"location":"resources/data_structures/#union-find-aka-dsu-o-disjoint-set-union","title":"Union Find (a.k.a. DSU o Disjoint Set Union)","text":"<ul> <li>cp-algorithms: Disjoint Set Union</li> <li>(youtube) 1.12 Disjoint Sets Data Structure - Weighted Union and Collapsing Find</li> <li>(youtube) Disjoint Sets using union by rank and path compression Graph Algorithm</li> <li>(youtube) Union Find Path Compression</li> <li>geeksforgeeks: Disjoint Set (Or Union-Find) | Set 1 (Detect Cycle in an Undirected Graph)</li> <li>geeksforgeeks: Union-Find Algorithm | Set 2 (Union By Rank and Path Compression)</li> <li>C\u00f3digo de ejemplo</li> </ul>"},{"location":"resources/data_structures/#treap","title":"Treap","text":"<ul> <li>https://cp-algorithms.com/data_structures/treap.html</li> </ul>"},{"location":"resources/data_structures/#wavelet-tree","title":"Wavelet Tree","text":"<ul> <li>https://www.dcc.uchile.cl/~jperez/papers/ioiconf16.pdf</li> <li>C\u00f3digo de ejemplo</li> </ul>"},{"location":"resources/divconq/","title":"Divide and Conquer","text":"<ul> <li>(Youtube) 2 Divide And Conquer</li> <li>(Youtube) Divide and Conquer Generic Method</li> <li>https://en.wikipedia.org/wiki/Divide-and-conquer_algorithm</li> <li>Ejemplos de aplicaciones:</li> <li>(Youtube) Merge sort in 3 minutes</li> <li>(Youtube) 2.7.2. Merge Sort Algorithm</li> <li>(Youtube) 2.8.1 QuickSort Algorithm</li> <li>(Youtube) Closest pair of points</li> <li>(Youtube) Finding the Closest Pair of Points on the Plane: Divide and Conquer</li> </ul>"},{"location":"resources/dp/","title":"Programaci\u00f3n Din\u00e1mica (DP)","text":""},{"location":"resources/dp/#que-es-dp","title":"\u00bfQu\u00e9 es DP?","text":"<ul> <li>What Is Dynamic Programming and How To Use It \\&lt;\\&lt;\\&lt;\\&lt;\\&lt; MUY BUEN VIDEO, V\u00c9ANLO!</li> <li>Principle of Optimality - Dynamic Programming introduction </li> <li>Algorithms: Memoization and Dynamic Programming</li> <li>19. Dynamic Programming I: Fibonacci, Shortest Paths</li> <li>Dos formas generales de usar DP: Bottom-Up vs Top-Down:</li> <li>http://stackoverflow.com/questions/6164629/dynamic-programming-and-memoization-bottom-up-vs-top-down-approaches</li> </ul>"},{"location":"resources/dp/#ejemplos-de-aplicaciones-de-dp","title":"Ejemplos de aplicaciones de DP","text":"<ul> <li>Coin Change: video</li> <li>Matrix Chain Multiplication: video1, video2</li> <li>Longest Increasing Subsequence (LIS): video, explicaci\u00f3n stackoverflow, c\u00f3digo ejemplo</li> <li>Knapsack problem: video</li> <li>Traveling Salesman Problem (TSP): video, implementaci\u00f3n usando bitmasks, c\u00f3digo ejemplo</li> <li>Minimum Edit Distance Between 2 Strings - The Levenshtein Distance: video1, video2</li> <li>Otros ejemplos: playlist</li> </ul>"},{"location":"resources/dp/#dp-avanzado","title":"DP Avanzado","text":"<ul> <li>Clase Optimizaciones de DP: https://youtu.be/wLSfdicxVLs</li> <li>Lista de Optimizaciones de DP: https://codeforces.com/blog/entry/8219</li> <li>Problemas para practicar Optimizaciones de DP: https://codeforces.com/blog/entry/47932</li> <li>Divide &amp; Conquer Optimization:</li> <li>https://jeffreyxiao.me/blog/divide-and-conquer-optimization</li> <li>(cp-algorithms) Divide and Conquer DP</li> <li>HackerRank: editorial explicando la t\u00e9cnica</li> <li>(youtube) Dynamic Programming Optimization: Divide and Conquer technique</li> <li>c\u00f3digo de ejemplo</li> <li>Convex Hull Trick:</li> <li>Codeforces: [Tutorial] Convex Hull Trick \u2014 Geometry being useful</li> <li>https://jeffreyxiao.me/blog/convex-hull-trick</li> <li>Knuth's Optimization:</li> <li>https://jeffreyxiao.me/blog/knuths-optimization</li> </ul>"},{"location":"resources/geometry/","title":"Geometr\u00eda","text":""},{"location":"resources/geometry/#apuntes-genericos-de-geometria","title":"Apuntes gen\u00e9ricos de geometr\u00eda","text":"<ul> <li>https://vlecomte.github.io/cp-geo.pdf (buen\u00edsimo y muy completo)</li> </ul>"},{"location":"resources/geometry/#producto-punto","title":"Producto Punto","text":"<ul> <li>Youtube: Dot products and duality | Chapter 9, Essence of linear algebra</li> <li>CodeForces: Geometry: 2D points and lines [Tutorial] (saltarse a la parte dot product)</li> <li>Youtube: Dot Product &amp; Angle Between Vectors</li> <li>Youtube: Cross Product and Dot Product: Visual explanation</li> </ul>"},{"location":"resources/geometry/#producto-cruz","title":"Producto Cruz","text":"<ul> <li>Youtube: Cross products - Essence of linear algebra, Chapter 10](https://www.youtube.com/watch?v=eu6i7WJeinw)</li> <li>Math is fun: Vector Cross Product</li> <li>StackOverlfow: Calculating a 2D Vector's Cross Product</li> <li>CodeForces: Geometry: 2D points and lines [Tutorial]</li> <li>Youtube: Cross Product and Dot Product: Visual explanation</li> </ul>"},{"location":"resources/geometry/#apuntes-varios-de-geometria-2d","title":"Apuntes varios de Geometr\u00eda 2D","text":"<ul> <li>apuntes de Benja</li> <li>apuntes de Pablo</li> <li>Video Repaso de Geometr\u00eda (muy bueno): youtube: Geometr\u00eda Computacional [ICPCCL 2016]</li> <li>CP-Algorithms: Geometry</li> </ul>"},{"location":"resources/geometry/#apuntes-varios-de-geometria-3d","title":"Apuntes varios de Geometr\u00eda 3D","text":"<ul> <li>apuntes de Benja</li> <li>apuntes de Pablo</li> </ul>"},{"location":"resources/geometry/#trigonometria","title":"Trigonometr\u00eda","text":"<ul> <li>implementaciones varias de trigonometr\u00eda</li> </ul>"},{"location":"resources/geometry/#algoritmos-varios-de-poligonos","title":"Algoritmos varios de Pol\u00edgonos","text":"<ul> <li>implementaciones varias de algoritmos sobre pol\u00edgonos</li> <li>Detectar si un punto est\u00e1 dentro de un pol\u00edgono:</li> <li>geomalgorithms: Inclusion of a Point in a Polygon</li> <li>wikipedia: Point in polygon</li> <li>Puntos extremos en un pol\u00edgono convexo:</li> <li>geomalgorithms: Extreme Points of Convex Polygons</li> <li>Pick's Theorem:</li> <li>https://cp-algorithms.com/geometry/picks-theorem.html</li> <li>https://cp-algorithms.com/geometry/lattice-points.html</li> </ul>"},{"location":"resources/geometry/#convex-hull","title":"Convex Hull","text":"<ul> <li>Buen video explicando Convex Hull: youtube: 5 6 Convex Hull 1350</li> <li>Monotone Chain Algorithm (algoritmo recomendado):</li> <li>https://en.wikibooks.org/wiki/Algorithm_Implementation/Geometry/Convex_hull/Monotone_chain</li> <li>C\u00f3digo de ejemplo</li> <li>Convex Hull Trick:</li> <li>https://wcipeg.com/wiki/Convex_hull_trick</li> <li>https://stackoverflow.com/questions/17834699/what-is-convex-hull-trick-exactly</li> </ul>"},{"location":"resources/geometry/#calculo-de-areas","title":"C\u00e1lculo de \u00c1reas","text":"<ul> <li>Teorema de Green (aplicado al caso particular de calcular \u00e1reas):</li> <li>lecturas:<ul> <li>https://math.stackexchange.com/questions/199003/proving-greens-theorem-for-computing-area</li> <li>https://mathinsight.org/greens_theorem_find_area</li> </ul> </li> <li>videos:<ul> <li>youtube: Green's Theorem</li> <li>youtube: 78 - Finding area with Green's theorem</li> <li>How to Use Green's Theorem to Find the Area of A Region</li> <li>Green's Theorem: area under an arch - MIT 18.02SC Multivariable Calculus, Fall 2010</li> </ul> </li> <li>C\u00f3digos de ejemplo</li> <li>Aplicaci\u00f3n a pol\u00edgonos - \u00e1rea de un pol\u00edgono simple:</li> <li>http://math.blogoverflow.com/2014/06/04/greens-theorem-and-area-of-polygons/</li> <li>http://stackoverflow.com/questions/451426/how-do-i-calculate-the-area-of-a-2d-polygon</li> <li>c\u00f3digo de ejemplo (ctrl+f \"area\")</li> </ul>"},{"location":"resources/geometry/#sweep-line-y-radial-sweep-line","title":"Sweep Line y Radial Sweep Line","text":"<ul> <li>codeforces: How to sweep like a Sir</li> <li>wikipedia: Sweep line algorithm</li> <li>topcoder: line sweep algorithms </li> </ul>"},{"location":"resources/geometry/#dualidad-linea-punto","title":"Dualidad L\u00ednea - Punto","text":"<ul> <li>Buenas slides explicando dualidad: https://algo.kaust.edu.sa/Documents/cs372l13.pdf</li> <li>Excelente pdf con demostraciones: https://pdfs.semanticscholar.org/810c/e0c19283481567c6545bf8c0cc8a4dcb8a1f.pdf</li> <li>Aplicaci\u00f3n interactiva: http://students.cec.wustl.edu/~tdeck/duality/</li> </ul>"},{"location":"resources/graphs/","title":"Grafos","text":""},{"location":"resources/graphs/#introduccion-a-grafos","title":"Introducci\u00f3n a Grafos","text":"<ul> <li>Slides de Nico Lehmann sobre Grafos (muy buenas):</li> <li>http://campamento2015.progcomp.cl/material (revisar la parte Grafos)</li> <li>http://campamento2016.progcomp.cl/material (revisar la parte Grafos)</li> <li>(youtube) Data structures: Introduction to graphs</li> <li>(youtube) Data structures: Properties of Graphs</li> <li>(youtube) Graph Representation part 01 - Edge List</li> <li>(youtube) Graph Representation part 02 - Adjacency Matrix</li> <li>(youtube) Graph Representation part 03 - Adjacency List</li> <li>(youtube) Graph Theory: 02. Definition of a Graph</li> <li>(youtube) Graph Theory: 03. Examples of Graphs</li> <li>(youtube) Graph Theory: 04. Families of Graphs</li> <li>(youtube) Graph Theory: 36. Definition of a Tree</li> <li>Grafo dirigido vs Grafo no-dirigido:</li> <li>(youtube) Graph Types Directed and Undirected Graph</li> <li>(geeksforgeeks) Graph and its representations</li> </ul>"},{"location":"resources/graphs/#algoritmos-de-graph-traversal","title":"Algoritmos de Graph Traversal","text":"<ul> <li>Breadth First Search (BFS):</li> <li>cp-algorithms: BFS</li> <li>c\u00f3digo de ejemplo</li> <li>Depth First Search (DFS):</li> <li>cp-algorithms: DFS</li> <li> <p>c\u00f3digo de ejemplo</p> </li> <li> <p>(youtube) 5.1 Graph Traversals - BFS &amp; DFS -Breadth First Search and Depth First Search</p> </li> <li>(youtube) Graph Traversals - Breadth First and Depth First</li> <li>(youtube) Graph : BFS, DFS</li> <li>(youtube) Algorithms: Graph Search, DFS and BFS</li> <li>Flood Fill: https://en.wikipedia.org/wiki/Flood_fill</li> </ul>"},{"location":"resources/graphs/#diametro-de-un-arbol","title":"Di\u00e1metro de un \u00c1rbol","text":"<ul> <li>cs.stackexchange: Algorithm to find diameter of a tree using BFS/DFS. Why does it work?</li> <li>c\u00f3digo de ejemplo</li> </ul>"},{"location":"resources/graphs/#topological-sort","title":"Topological Sort","text":"<ul> <li>(youtube) Topological Sort Algorithm | Graph Theory</li> <li>(youtube) Topological Sort Graph Algorithm</li> <li>Codeforces - How to check cycles inside a Topological Sort</li> <li>C\u00f3digos de ejemplo</li> </ul>"},{"location":"resources/graphs/#algoritmos-de-camino-mas-corto-shortest-path","title":"Algoritmos de Camino M\u00e1s Corto (Shortest Path)","text":"<ul> <li>De un nodo (single source) a todos los dem\u00e1s nodos:</li> <li> </li> <li> </li> <li>De todos los nodos (multiple source) a todos los nodos:</li> <li> </li> </ul>"},{"location":"resources/graphs/#dijkstra-cuando-no-hay-aristas-negativas","title":"Dijkstra (cuando NO hay aristas negativas)","text":"<ul> <li>(youtube) Dijkstra's algorithm in 3 minutes \u2014 Review and example</li> <li>(youtube) Dijkstra's Algorithm (5 minutos)</li> <li>(youtube) Muy buen ejemplo de Dijkstra</li> <li>(youtube) Correctness of Dijkstra's Algorithm</li> <li>cp-algorithms: dijkstra (incluye c\u00f3digo de ejemplo)</li> <li>C\u00f3digo de ejemplo</li> <li>C\u00f3digo de ejemplo Ignacio</li> </ul>"},{"location":"resources/graphs/#bellman-ford-cuando-si-hay-aristas-negativas","title":"Bellman-Ford (cuando S\u00cd hay aristas negativas)","text":"<ul> <li>(youtube) Bellman-Ford in 5 minutes \u2014 Step by step example</li> <li>(youtube) Bellman-Ford in 4 minutes \u2014 Theory</li> <li>(youtube) Bellman Ford Algorithm | Shortest path &amp; Negative cycles | Graph Theory</li> <li>(video) Bellman-Ford Algorithm: Proof of Correctness</li> <li>(youtube) Bellman Ford Algorithm - Single Source Shortest Path - Dynamic Programming (17m)</li> <li>cp-algorithms: bellman-ford (incluye c\u00f3digos de ejemplo)</li> <li>C\u00f3digo de ejemplo</li> <li>\u00bfC\u00f3mo detectar un ciclo negativo con Bellman-Ford?</li> <li>GeeksforGeeks - Detect a negative cycle in a Graph | (Bellman Ford)</li> <li>(PDF) Proof of Correctness</li> </ul>"},{"location":"resources/graphs/#floyd-warshall","title":"Floyd-Warshall","text":"<ul> <li>(youtube) Floyd\u2013Warshall algorithm in 4 minutes</li> <li>(youtube) All Pairs Shortest Path (Floyd-Warshall) - Dynamic Programming (14m)</li> <li>cp-algorithms: floyd-warshall (incluye c\u00f3digo de ejemplo)</li> <li>C\u00f3digo de ejemplo</li> <li>\u00bfQu\u00e9 pasa cuando hay ciclos negativos?</li> <li>(wikipedia) Behavior_with_negative_cycles</li> <li>Floyd-Warshall with negative cycles. How do I find all undefined paths?</li> </ul>"},{"location":"resources/graphs/#minimum-spanning-tree-mst","title":"Minimum Spanning Tree (MST)","text":"<ul> <li>(youtube) 3.5 Prims and Kruskals Algorithms - Greedy Method</li> <li>Kruskal's Algorithm:</li> <li>(youtube) Kruskal's algorithm in 2 minutes \u2014 Review and example</li> <li>(youtube) Kruskal's algorithm Minimum Spanning Tree Graph Algorithm</li> <li>Prim's Algorithm:</li> <li>(youtube) Prim's algorithm in 2 minutes \u2014 Review and example</li> <li>(youtube) Prim's Algorithm Minimum Spanning Tree Graph Algorithm</li> <li>Correcteness Proofs:</li> <li>(youtube) Proof of Cut Property</li> <li>(youtube) Proof of Prim's MST algorithm using cut property</li> <li>(youtube) Correctness of Kruskal's Algorithm</li> <li>cp-algorithms:</li> <li>Minimum Spanning Tree - Prim's Algorithm</li> <li>Minimum Spanning Tree - Kruskal</li> <li>Minimum Spanning Tree - Kruskal with Disjoint Set Union</li> <li>Second best Minimum Spanning Tree - Using Kruskal and Lowest Common Ancestor</li> <li>C\u00f3digos de ejemplo</li> </ul>"},{"location":"resources/graphs/#lowest-common-ancestor-lca","title":"Lowest Common Ancestor (LCA)","text":"<ul> <li>General Overview of Methods:</li> <li>http://codeforces.com/blog/entry/16221 (skip to the LCA part)</li> <li>M\u00e9todo 1 (RECOMENDADO): Binary Lifting Method (aka jump pointers):</li> <li>Codeforces: Lowest common ancestor's binary lifting method for path queries on trees Nota: como dice el post, este m\u00e9todo es muy \u00fatil ya que se puede adaptar para computar consultas sobre caminos entre 2 nodos en un \u00e1rbol.</li> <li>(youtube) Episode 17 - Binary Lifting</li> <li>M\u00e9todo 2: Euler Tour + Range Minimun Query:</li> <li>Topcoder: range minimum query and lowest common ancestor</li> <li>(youtube) Episode 28 - Sparse Tables and LCA</li> <li>(youtube) Sparse Table Algorithm Range Minimum Query</li> <li> <p>C\u00f3digos de ejemplo (ambos m\u00e9todos)</p> </li> <li> <p>Level Ancestor:</p> </li> <li>https://en.wikipedia.org/wiki/Level_ancestor_problem</li> <li>https://www.quora.com/Why-does-storing-log-N-pointers-work-in-the-jump-pointer-solution-of-the-level-ancestor-problem</li> <li>C\u00f3digo de ejemplo</li> </ul>"},{"location":"resources/graphs/#puntos-de-articulacion-aristas-de-corte-y-componentes-biconexas","title":"Puntos de articulaci\u00f3n, Aristas de corte y Componentes Biconexas","text":"<ul> <li>(youtube) Graph Theory: 53. Cut-Vertices</li> <li>(youtube) Graph Theory: 55. Bridges and Blocks</li> <li>HackerEarth: Articulation Points and Bridges</li> <li>HackerEarth: Biconnected Components</li> <li>(PDF) MTL776 Graph algorithms: Cut vertices, Cut Edges and Biconnected components</li> <li>(youtube) 5.2 Articulation Point and Biconnected Components</li> <li>(youtube) Articulation Points Graph Algorithm</li> <li>C\u00f3digo de ejemplo</li> <li>Teoremas relevantes:</li> <li>Menger's Theorem<ul> <li>https://en.wikipedia.org/wiki/Menger%27s_theorem</li> <li>(youtube) Menger's Theorem</li> <li>https://www.quora.com/How-can-I-prove-without-using-Mengers-theorem-that-any-two-vertices-of-a-2-connected-graph-lie-on-a-common-cycle</li> </ul> </li> </ul>"},{"location":"resources/graphs/#strongly-connected-components-scc","title":"Strongly Connected Components (SCC)","text":"<ul> <li>M\u00e9todo 1: Tarjan's Algorithm for SCC</li> <li>(youtube) Tarjans Strongly Connected Components algorithm | Graph Theory</li> <li>(geeksforgeeks) Tarjan\u2019s Algorithm to find Strongly Connected Components</li> <li>M\u00e9todo 2: Kosaraju's Algorithm for SCC</li> <li>(youtube) Strongly Connected Components Kosaraju's Algorithm Graph Algorithm</li> <li>(geeksforgeeks) Kosaraju's Algorithm to find Strongly Connected Components</li> <li>(cp-algorithms) Finding strongly connected components, Building condensation graph</li> <li>(quora) Diferencias entre Tarjan y Kosaraju</li> <li>C\u00f3digos de ejemplo</li> </ul>"},{"location":"resources/graphs/#flujo-maximo-y-aplicaciones","title":"Flujo M\u00e1ximo y aplicaciones","text":"<ul> <li>(youtube) Episode 33 - Maximum Flow Intuition</li> <li>Cu\u00e1ndo se usa:</li> <li>(MUY RECOMENDADO) (youtube) Ejemplos de problemas usando flujo</li> <li>geeksforgeeks: Maximum Bipartite Matching</li> <li>Ford-Fulkerson Algorithm:</li> <li>(youtube) Ford-Fulkerson in 5 minutes \u2014 Step by step example</li> <li>(youtube) Residual Networks - Georgia Tech - Computability, Complexity, Theory: Algorithms</li> <li>(youtube) Edmonds Karp Algorithm to find the Max Flow</li> <li>(youtube) Ford Fulkerson Algorithm Edmonds Karp Algorithm For Max Flow</li> <li>Intuici\u00f3n detr\u00e1s del grafo residual: cs.stackexchnge: Residual Graph in Maximum Flow </li> <li>Dinic Algorithm (RECOMENDADO):</li> <li>(youtube) CS261 Lecture 2 (Edmonds-Karp/Dinic algorithms)</li> <li>(PDF) CMU, 15-451 Algorithms, Fall 2014: Lecture 11: Dinic\u2019s Algorithm</li> <li>(PDF) Stanford, CS261: A Second Course in Algorithms, Lecture #2: Augmenting Path Algorithms for Maximum Flow</li> <li>C\u00f3digo de ejemplo</li> </ul>"},{"location":"resources/graphs/#heavy-light-decomposition","title":"Heavy-Light Decomposition","text":"<ul> <li>https://cp-algorithms.com/graph/hld.html</li> <li>https://blog.anudeep2011.com/heavy-light-decomposition/</li> <li>https://www.geeksforgeeks.org/heavy-light-decomposition-set-1-introduction/</li> <li>http://codeforces.com/blog/entry/22072</li> </ul>"},{"location":"resources/greedy/","title":"Greedy","text":"<ul> <li>(Youtube) Introduction to Greedy Algorithms - GeeksforGeeks</li> <li>(Youtube) Introduction to Greedy Method</li> <li>(Youtube) 3. Greedy Method - Introduction</li> <li>(Youtube) Greedy Algorithms Tutorials - GeeksforGeeks</li> </ul>"},{"location":"resources/math/","title":"Matem\u00e1ticas","text":""},{"location":"resources/math/#numeros-primos","title":"N\u00fameros Primos","text":"<ul> <li>\u00bfQu\u00e9 es un n\u00famero primo?</li> <li>What's a Prime Number?</li> <li>Wikipedia - Prime Number</li> <li>Teorema fundamental de la aritm\u00e9tica: todo natural tiene una \u00fanica factorizaci\u00f3n prima</li> <li>wikipedia - Fundamenetal theorem of arithmetic</li> <li>The Fundamental Theorem of Arithmetic</li> <li>Number Theory - Fundamental Theorem of Arithmetic</li> <li>Tests de Primalidad (c\u00f3mo saber si un n\u00famero es primo):</li> <li>CP-Algorithms: Primality tests</li> <li>stackoverflow - Fastest algorithm for primality test</li> <li>Miller Rabin:<ul> <li>cp-algorithms: Miller Rabin</li> <li>https://www.geeksforgeeks.org/primality-test-set-3-miller-rabin/</li> <li>deterministic variant: https://miller-rabin.appspot.com/</li> </ul> </li> <li>C\u00f3digos de ejemplo</li> <li>Criba de Erat\u00f3stenes (todos los primos hasta N):</li> <li>wikipedia: Sieve of Eratosthenes (hay un GIF muy bueno)</li> <li>(youtube) Finding Prime numbers - Sieve of Eratosthenes</li> <li>(youtube) Criba de Erat\u00f3stenes [ICPCCL 2016]</li> <li>C\u00f3digo de ejemplo</li> <li>Criba de Erat\u00f3stenes Segmentada (m\u00e1s r\u00e1pida):</li> <li>https://github.com/kimwalisch/primesieve/wiki/Segmented-sieve-of-Eratosthenes</li> <li>(cp-algorithms) Segmented sieve of eratosthenes</li> <li>(geeksforgeeks) Segmented Sieve (Print Primes in a Range)</li> <li>Factorizaci\u00f3n Prima de N\u00fameros Enteros:</li> <li>cp-algorithms: Integer factorization</li> <li>c\u00f3digo de ejemplo</li> <li>Factorizaci\u00f3n Prima de Factoriales:</li> <li>http://mathforum.org/library/drmath/view/67291.html</li> <li>https://janmr.com/blog/2010/10/prime-factors-of-factorial-numbers/</li> <li>https://forthright48.com/prime-factorization-of-factorial/</li> <li>c\u00f3digo de ejemplo</li> </ul>"},{"location":"resources/math/#aritmetica-modular","title":"Aritm\u00e9tica Modular","text":"<ul> <li>\u00bfDe qu\u00e9 se trata Aritm\u00e9tica Modular?</li> <li>Art of Problem Solving: Modular Arithmetic / Introduction</li> <li>(wikipedia) Modular Arithmetic</li> <li>(youtube) Introduction to Modular arithmetic</li> <li>(youtube) High level introduction to modular arithmetic</li> <li>(youtube) Congruence (Modular Arithmetic) &amp; 5 Properties Explained with 7 Problems: Ultimate Shortcuts</li> <li> <p>(wikipedia) Identidades en Aritm\u00e9tica Modular</p> </li> <li> <p>Modular Inverse:</p> </li> <li>cp-algorithms - Modular Inverse</li> <li>Youtube - Multiplicative inverses mod n</li> <li>Modular Exponentiation By Squaring:</li> <li>https://en.wikipedia.org/wiki/Modular_exponentiation#Right-to-left_binary_method</li> <li>https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Mathematics/binary_modular_exponentiation.cpp</li> <li>Modular Fibonacci with Exponentiation by Squaring:</li> <li>http://mathoverflow.net/questions/40816/fibonacci-series-mod-a-number</li> </ul>"},{"location":"resources/math/#binary-exponentiation","title":"Binary Exponentiation","text":"<ul> <li>(cp-algorithms) Binary Exponentiation</li> <li>C\u00f3digo de ejemplo</li> </ul>"},{"location":"resources/math/#conteo-y-combinatoria-modular","title":"Conteo y Combinatoria modular","text":"<ul> <li>Muy buen art\u00edculo sobre distintos m\u00e9todos para calcular combinatorias</li> <li>Modular Binomial Coefficient (Choose(n,k) mod X): c\u00f3digo de ejemplo</li> <li>Modular Multinomial Coefficient: c\u00f3digo de ejemplo</li> </ul>"},{"location":"resources/math/#algoritmo-de-euclides","title":"Algoritmo de Euclides","text":"<p>c\u00f3mo encontrar el GCD entre dos n\u00fameros</p> <ul> <li>(youtube) Euclidean Algorithm (Proof)</li> <li>(youtube) Number Theory: Euclidean Algorithm - An example</li> <li>(cp-algorithms) Euclidean algorithm for computing the greatest common divisor</li> <li>(youtube) (Discrete Math 1) Euclidian Algorithm</li> <li>Euclidean Algorithm \u2013 Greatest Common Divisor</li> <li>(geeksforgeeks) std::gcd | C++ inbuilt function for finding GCD</li> </ul> <p>LCM (m\u00ednimo com\u00fan m\u00faltiplo): https://cp-algorithms.com/algebra/euclid-algorithm.html (revisar final de la p\u00e1gina)</p>"},{"location":"resources/math/#algoritmo-de-euclides-extendido-gcdext","title":"Algoritmo de Euclides Extendido (gcdext)","text":"<ul> <li>https://forthright48.com/extended-euclidean-algorithm/</li> <li>(cp-algorithms) Extended Euclidean Algorithm</li> <li>(math.stackexchange) gcdext con n\u00fameros negativos?</li> <li>(youtube) Algoritmo de Euclides [ICPCCL 2016]</li> <li>(youtube) The Extended Euclidean algorithm</li> <li> <p>c\u00f3digo de ejemplo</p> </li> <li> </li> <li> </li> <li> </li> <li> </li> <li>C\u00f3digos de ejemplos</li> </ul>"},{"location":"resources/math/#aplicaciones-de-euclides-extendido","title":"Aplicaciones de Euclides Extendido","text":""},{"location":"resources/math/#modular-inverse","title":"Modular Inverse","text":"<ul> <li>(cp-algorithms) modular inverse</li> </ul>"},{"location":"resources/math/#linear-diophantine-equations","title":"Linear Diophantine Equations","text":"<ul> <li>(cp-algorithms) linear dophantine equation</li> <li>(youtube) N1--Introduction to Linear Diophantine Equations</li> <li>(youtube) N2--Solve Basic Linear Diophantine Equation</li> <li>(youtube) Number Theory: Diophantine Equation: ax+by=gcd(a,b)</li> <li>(PDF) http://gauss.math.luc.edu/greicius/Math201/Fall2012/Lectures/linear-diophantine.article.pdf</li> <li>http://mathonline.wikidot.com/solutions-to-linear-diophantine-equations</li> </ul>"},{"location":"resources/math/#linear-congruence-equation","title":"Linear Congruence Equation","text":"<ul> <li>(cp-algorithms) Linear Congruence Equation</li> <li>(PDF) http://gauss.math.luc.edu/greicius/Math201/Fall2012/Lectures/linear-congruences.article.pdf</li> </ul>"},{"location":"resources/math/#chinese-remainder-theorem-crt","title":"Chinese Remainder Theorem (CRT)","text":"<ul> <li>(codeforces) [Tutorial] Chinese Remainder Theorem</li> <li>(youtube) The Chinese Remainder Theorem made easy</li> <li>(youtube) Chinese Remainder Theorem</li> <li>Chinese Remainder Theorem Part 1 \u2013 Coprime Moduli</li> <li>Chinese Remainder Theorem Part 2 \u2013 Non Coprime Moduli</li> <li>c\u00f3digo de ejemplo</li> </ul>"},{"location":"resources/math/#lucass-theorem","title":"Lucas's theorem","text":"<ul> <li>wikipedia - Lucas's theorem</li> <li>choose(n,k) mod M using Chinese remainder theorem? </li> </ul>"},{"location":"resources/math/#eulers-theorem-eulers-totient-function","title":"Euler's Theorem &amp; Euler's Totient Function","text":"<ul> <li>wikipedia - Euler's Theorem</li> <li>wikipedia - Euler's Totient Function</li> <li>cp-algorithms: Euler's Totient Function</li> </ul>"},{"location":"resources/math/#integracion-numerica","title":"Integraci\u00f3n Num\u00e9rica","text":"<ul> <li>(Wikipedia) https://en.wikipedia.org/wiki/Numerical_integration</li> <li>(Codeforces Tasks involving numerical integration</li> <li>(youtube) Explanation of Simpson's rule | MIT 18.01SC Single Variable Calculus, Fall 2010</li> <li>(youtube) Simpson's Rule &amp; Numerical Integration</li> <li>(youtube) Numerical Integration With Trapezoidal and Simpson's Rule</li> </ul>"},{"location":"resources/search/","title":"(Bi|Ter)nary Search","text":""},{"location":"resources/search/#binary-search","title":"Binary Search","text":"<ul> <li>Youtube - Excelente video explicando binary search (RECOMENDADO)</li> <li>Youtube - muy buena comparaci\u00f3n entre linear search y binary search (+ c\u00f3digo)</li> <li>Youtube - Algorithms: Binary Search</li> <li>http://progcomp.cl/binarysearch</li> <li>Ejemplo de implementaci\u00f3n en C++</li> <li>geeksforgeeks - Binary Search functions in C++ STL (binary_search, lower_bound and upper_bound)</li> <li>caso especial: binary search on doubles - codeforces cuando el problema es continuo (no-discreto)</li> </ul>"},{"location":"resources/search/#ternary-search","title":"Ternary Search","text":"<ul> <li>https://www.hackerearth.com/practice/algorithms/searching/ternary-search/tutorial/</li> <li>https://en.wikipedia.org/wiki/Ternary_search</li> <li>https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Search/TernarySearch.cpp</li> <li>C\u00f3mo reducir Ternary Search a Binary Search: Codeforces - The great ternary search hoax</li> </ul>"},{"location":"resources/sqrtdecomp/","title":"Square Root Decomposition","text":"<ul> <li>cp-algorithms: square decomposition</li> <li>Mo's Algorithm:</li> <li>cp-algorhtms: Mo's algorithm</li> <li>geeksforgeeks: Mo's algorithm (query square root decomposition)</li> <li>geeksforgeeks: extended Mo's algorithm (O(1) time complexity)</li> </ul>"},{"location":"resources/strings/","title":"Strings","text":""},{"location":"resources/strings/#suffix-automaton","title":"Suffix Automaton","text":"<ul> <li>codeforces - A short guide to suffix automata</li> <li>https://cp-algorithms.com/string/suffix-automaton.html</li> <li>youtube - Suffix Automation Explanation</li> </ul>"},{"location":"resources/strings/#suffix-array","title":"Suffix Array","text":"<ul> <li>\u00bfQu\u00e9 es un suffix array?: Youtube - Suffix Array introduction</li> <li>Motivaci\u00f3n para Suffix Arrays: Youtube - 35 6 Suffix Arrays</li> <li>C\u00f3mo construir un Suffix Array eficientemente:</li> <li>Youtube - Construction of suffix arrays</li> <li>https://www.cs.helsinki.fi/u/tpkarkka/opetus/10s/spa/lecture11.pdf</li> <li>HackerRank - Suffix Array</li> <li>cp-algorithms: Suffix Array</li> <li>Longest Common Prefix (LCP):</li> <li>Youtube - Longest Common Prefix (LCP) array</li> <li>Codeforces - LCP from suffix array</li> <li>geeksforgeeks - kasai\u2019s Algorithm for Construction of LCP array from Suffix Array</li> <li>C\u00f3digos de Ejemplo:</li> <li>suffix_array.cpp</li> <li>Codeforces - Suffix Arrays</li> </ul>"},{"location":"resources/strings/#kmp-string-pattern-matching","title":"KMP (String Pattern Matching)","text":"<ul> <li>youtube: KMP String matching algorithm</li> <li>youtube: KMP Searching Algorithm</li> <li>youtube: 9.1 Knuth-Morris-Pratt KMP String Matching Algorithm</li> <li>youtube: Knuth\u2013Morris\u2013Pratt(KMP) Pattern Matching(Substring search)</li> <li>youtube: Knuth\u2013Morris\u2013Pratt(KMP) Pattern Matching(Substring search) Part2</li> <li>cp-algorithms: KMP</li> <li>c\u00f3digo de ejemplo</li> <li>Shortest Repeating Cycle<ul> <li>http://www.geeksforgeeks.org/find-given-string-can-represented-substring-iterating-substring-n-times/</li> <li>http://stackoverflow.com/questions/6021274/finding-shortest-repeating-cycle-in-word</li> <li>c\u00f3digo de ejemplo</li> </ul> </li> </ul>"},{"location":"resources/strings/#trie","title":"Trie","text":"<ul> <li>https://en.wikipedia.org/wiki/Trie</li> <li>youtube - Data Structures: Tries</li> <li>youtube - Trie Data Structure</li> <li>C\u00f3digo de ejemplo</li> </ul>"},{"location":"resources/strings/#rolling-hashing","title":"Rolling Hashing","text":"<ul> <li>https://progcomp.cl/rollinghashing</li> <li>cp-algorithms: String Hashing</li> <li>c\u00f3digo de ejemplo</li> </ul>"},{"location":"resources/cpp/","title":"C++","text":"Ejemplo de Hello World<pre><code>#include &lt;bits/stdc++.h&gt; //importa todo\nusing namespace std; //para no escribir std::\nint main()\n{\nprintf(\"Hello world\\n\"); //Usando syntax de C\ncout &lt;&lt; \"Hello world\\n\"; //Usando streams de C++\nreturn 0;\n}\n</code></pre> Ejemplo de Template<pre><code>#pragma GCC optimize(\"Ofast\")\n#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// defines\n#define rep(i,a,b) for(int i = a; i &lt; b; ++i)\n#define invrep(i,b,a) for(int i = b; i &gt;= a; --i)\n#define umap unordered_map\n#define uset unordered_set\n#define ff first\n#define ss second\n// typedefs\ntypedef pair&lt;int,int&gt; ii;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\n// -------------------------------\nint main() {\nios::sync_with_stdio(false); cin.tie(0);\nreturn 0;\n}\n</code></pre>"},{"location":"resources/cpp/#instalando-c","title":"Instalando C++","text":"<ul> <li>Windows:<ul> <li>Usando GCC con MinGW</li> <li>MSYS2</li> </ul> </li> <li>Linux:<ul> <li>Debian o Ubuntu (apt)     Usar el comando<pre><code>    sudo apt-get install g++\n</code></pre></li> <li>Arch Linux (pacman)     Usar el comando<pre><code>    sudo pacman -S g++\n</code></pre></li> <li>CentOS, Fedora, o RHEL (yum)     Usar el comando<pre><code>    sudo yum install gcc-c++\n</code></pre> Compilar con g++</li> </ul> </li> <li>Mac:<ul> <li>Installer en OSX</li> <li>Compilar con CLang</li> </ul> </li> </ul>"},{"location":"resources/cpp/#compilando-y-ejecutando-codigo-en-c","title":"Compilando y ejecutando c\u00f3digo en C++:","text":"<p>Ejemplo de secuencia de pasos para resolver un problema en C++ en Windows usando la terminal (en Linux/Mac es bien parecido):</p> <ul> <li>Crear un archivo <code>example.cpp</code></li> <li>Escribir un c\u00f3digo de C++ v\u00e1lido y guardar.</li> <li>Abrir una terminal y navegar a la carpeta donde est\u00e1 el archivo.</li> <li>Opci\u00f3n 1:<ul> <li>En la terminal, compilar y ejecutar con el comando:  <pre><code>    g++ -std=c++11 example.cpp &amp;&amp; a.exe\n</code></pre></li> <li>Escribir el input directamente en la terminal</li> <li>El output ir\u00e1 apareciendo poco a poco en la terminal (intercalado con el input)</li> </ul> </li> <li>Opci\u00f3n 2:<ul> <li>Crear un archivo en la carpeta donde est\u00e1n parados llamado input.txt, copiar y pegar el input ah\u00ed y guardar.</li> <li>En la terminal, compilar y ejecutar con el comando:  <pre><code>    g++ -std=c++11 example.cpp &amp;&amp; a.exe &lt; input.txt\n</code></pre></li> <li>el output aparecer\u00e1 en la misma terminal</li> </ul> </li> <li>Opci\u00f3n 3:<ul> <li>Crear un archivo en la carpeta donde est\u00e1n parados llamado input.txt, copiar y pegar el input ah\u00ed y guardar.</li> <li>En la terminal, compilar y ejecutar con el comando:  <pre><code>    g++ -std=c++11 example.cpp &amp;&amp; a.exe &lt; input.txt &gt; output.txt\n</code></pre></li> <li>el output quedar\u00e1 guardado en el archivo <code>output.txt</code>.</li> </ul> </li> </ul>"},{"location":"resources/cpp/#tutoriales-para-aprender-c","title":"Tutoriales para aprender C++","text":"<ul> <li>(youtube) Intro a la Programaci\u00f3n Competitiva en C++ (&lt;&lt;&lt;&lt; video cortito, recomendado)</li> <li>C++ for Python Programmers (&lt;&lt;&lt;&lt; por si vienes de Python)</li> <li>C++ Tutorial (SOLO LEARN: EVERYONE CAN CODE)</li> <li>http://www.cplusplus.com/doc/tutorial/</li> <li>https://www.hackerrank.com/domains/cpp</li> <li>LearnCpp</li> <li>Documentaci\u00f3n Oficial de C++</li> <li>(youtube) Intro a C++</li> <li>(youtube) Estructuras b\u00e1sicas en C++</li> <li>(youtube) C++ Programming Video Tutorials For Beginners [ Complete Series ]</li> <li>INPUT / OUTPUT:<ul> <li>Yet again on C++ input/output</li> <li>\u00bfQu\u00e9 es mejor para leer input / imprimir output? cin/cout vs printf/scanf</li> </ul> </li> </ul>"},{"location":"resources/cpp/#tips-de-implementacion-en-c-muy-utiles-en-progcomp","title":"Tips de implementaci\u00f3n en C++ (muy \u00fatiles en progcomp)","text":"<ul> <li>Cosas \u00fatiles que deber\u00edan saber de C++11 (PARA ESCRIBIR C\u00d3DIGOS M\u00c1S CORTOS Y ELEGANTES):<ul> <li>Tutorial: C++11 for programming contests</li> <li>Learn C++ 11 in 20 Minutes - Part I</li> <li>Learn C++ 11 in 20 Minutes - Part II</li> </ul> </li> <li> <p>Los beneficios de usar references (&amp;) y pointers (*) (para no copiar todo por valor y as\u00ed ser m\u00e1s eficientes):</p> <ul> <li>Diferencia entre references y pointers explicada (&lt;&lt;&lt;&lt; muy buen art\u00edculo, 100% recomendado)</li> <li>geeksforgeeks - Passing vector to a function in C++</li> <li>geeksforgeeks - When do we pass arguments by reference or pointer? </li> </ul> </li> <li> <p>Codeforces - Manejo de Strings en C++ (buenos tips para cuando tienen que leer input)</p> </li> <li>Youtube playlist: lista exhaustiva de videos cubriendo much\u00edsimos aspectos de C++</li> <li>STL: standard template library (buen material sobre la standard library de C++, MUY RECOMENDADO)<ul> <li>Introduction of STL #1: Overview</li> <li>Introduction of STL #2: Sequence Containers</li> <li>Introduction of STL #3: Associative Containers</li> <li>Introduction of STL #4: Unordered Containers</li> <li>Introduction of STL #5: Iterators and Algorithms</li> <li>Introduction of STL #6: Functors</li> <li>Topcoder: power up c++ with the standard template library part 1</li> <li>Topcoder: power up c++ with the standard template library part 2</li> <li>Youtube playlist: varios algoritmos de la librer\u00eda est\u00e1ndar de C++ para llegar y usar</li> </ul> </li> <li>Para aprender a trabajar con bits (operaciones bitwise):<ul> <li>Tutorial sobre Bitwise Operators</li> <li>\u00bfQu\u00e9 es bit masking?</li> <li>geeksforgeeks - Bitwise hacks for competitive programming</li> <li>geeksforgeeks - Bit Tricks for competitive programming</li> </ul> </li> <li>\u00bfQu\u00e9 son y para qu\u00e9 sirven Structs y Classes en C++?<ul> <li>Advanced C++: Struct Vs. Class</li> <li>Introduction to Structures in C++ CPP Programming Video Tutorial</li> <li>Buckys C++ Programming Tutorials - 12 - Introduction to Classes and Objects</li> <li>Structure and Class differences in C++ C ++ Tutorial Mr. Kishore</li> <li>CLASSES vs STRUCTS in C++</li> </ul> </li> </ul>"},{"location":"resources/cpp/#c-cheat-sheets-tricks","title":"C++ Cheat Sheets &amp; Tricks:","text":"<ul> <li>C++ Cheat Sheet for ACM ICPC <ul> <li>Aqu\u00ed pueden encontrar un C++ Solution Template (c\u00f3digo que uno siempre escribe al comenzar una soluci\u00f3n) + MUCHO MUCHO m\u00e1s :)</li> </ul> </li> <li>C++ STL cheatsheet for competitive programming</li> <li>C++ Tricks</li> <li>C++ tricks for competitive programming (for C++ 11)</li> <li>C++ Cheat Sheet de Pablo Messina</li> </ul>"},{"location":"resources/cpp/cpp_osx/","title":"Compiladores de C++ para OSX","text":""},{"location":"resources/cpp/cpp_osx/#default","title":"Default","text":"<p>OSX en general ya tiene instalado g++ y clang, esto se puede revisar haciendo lo siguiente en alg\u00fan terminal <code>which g++</code> con lo cual deber\u00eda salir <code>/usr/bin/g++</code>. Igualmente con clang, <code>which clang</code> y deber\u00eda salir <code>/usr/bin/clang</code></p>"},{"location":"resources/cpp/cpp_osx/#usando-brew","title":"Usando Brew","text":""},{"location":"resources/cpp/cpp_osx/#que-es-brew","title":"\u00bfQu\u00e9 es Brew?","text":"<p>Brew es un packet manager para OSX, es f\u00e1cil de usar. Su p\u00e1gina es esta.</p>"},{"location":"resources/cpp/cpp_osx/#instalar-g","title":"Instalar g++","text":"<p>Cuando uno quiere instalar g++ uno busca gcc <pre><code>brew search gcc\n</code></pre> Con esto aparecen varias opciones, por ejemplo <code>gcc@7</code>. Para instalarlo se usa <pre><code>brew install gcc@7\n</code></pre> Y una vez instalado uno lo usa de la siguiente forma <pre><code>g++-7 input_file.cpp\n</code></pre></p>"}]}